{"ast":null,"code":"import { abi as IUniswapV2Router02ABI } from \"../abis/IUniswapV2Router02.json\";\nimport { abi as IUniswapV2PairABI } from \"@uniswap/v2-core/build/IUniswapV2Pair.json\";\nimport ERC20ABI from \"../abis/ERC20.json\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { Contract } from \"@ethersproject/contracts\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { parseUnits, formatUnits } from \"@ethersproject/units\";\nimport { JSBI, Token, TokenAmount, TradeType, Route, Trade, Fetcher, Percent, WETH, ETHER, CurrencyAmount, InsufficientReservesError } from \"@uniswap/sdk\";\nimport { MaxUint256 } from \"@ethersproject/constants\";\nexport const INITIAL_ALLOWED_SLIPPAGE = 50; //bips\n\nexport const ROUTER_ADDRESS = \"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\"; // export const ROUTER_ADDRESS = \"0xF3726d6acfeda3E73a6F2328b948834f3Af39A2B\";\n\nexport const supportedTokens = [{\n  symbol: \"USDC\",\n  address: \"0x4DBCdF9B62e891a7cec5A2568C3F4FAF9E8Abe2b\",\n  decimal: 6\n}, {\n  symbol: \"ETH\",\n  address: \"0xc778417E063141139Fce010982780140Aa0cD5Ab\",\n  decimal: 18\n}, {\n  symbol: \"TEST\",\n  address: \"0xAEd3ed6cF66E1CB13ab8DC312a0dC91bc0936721\",\n  decimal: 18\n}, {\n  symbol: \"WBTC\",\n  address: \"0x577d296678535e4903d59a4c929b718e1d575e0a\",\n  decimal: 8\n}];\nexport function isAddress(value) {\n  try {\n    return getAddress(value);\n  } catch {\n    return false;\n  }\n} // account is not optional\n\nexport function getSigner(library, account) {\n  return library.getSigner(account).connectUnchecked();\n} // account is optional\n\nexport function getProviderOrSigner(library, account) {\n  return account ? getSigner(library, account) : library;\n} // account is optional\n\nexport function getContract(address, ABI, library, account) {\n  if (!isAddress(address) || address === AddressZero) {\n    throw Error(`Invalid 'address' parameter '${address}'.`);\n  }\n\n  return new Contract(address, ABI, getProviderOrSigner(library, account));\n}\nexport function getRouterContract(library, account) {\n  return getContract(ROUTER_ADDRESS, IUniswapV2Router02ABI, library, account);\n}\nexport function getPairContract(pairAddress, library, account) {\n  return getContract(pairAddress, IUniswapV2PairABI, library, account);\n} // return gas with 10% added margin in BigNumber\n\nexport function calculateGasMargin(value) {\n  console.log(\"just calculateGasMargin\");\n  return value.mul(BigNumber.from(10000).add(BigNumber.from(1000))).div(BigNumber.from(10000));\n} // check if hex string is zero\n\nexport function isZero(hexNumberString) {\n  return /^0x0*$/.test(hexNumberString);\n} // return token allowance in BigNumber\n\nexport async function getAllowance(tokenAddress, owner, spender, library, account) {\n  let tokenContract = getContract(tokenAddress, ERC20ABI, library, account);\n  let allowance = await tokenContract.allowance(owner, spender);\n  console.log(allowance);\n  return allowance;\n} // a custom error class for custom error text and handling\n\nexport class ACYSwapErrorStatus {\n  getErrorText() {\n    return this.errorText;\n  }\n\n  constructor(errorText) {\n    this.errorText = errorText;\n  }\n\n} // taken from Uniswap, used for price impact and realized liquid provider fee\n\nexport function computeTradePriceBreakdown(trade) {\n  const BASE_FEE = new Percent(JSBI.BigInt(30), JSBI.BigInt(10000));\n  const ONE_HUNDRED_PERCENT = new Percent(JSBI.BigInt(10000), JSBI.BigInt(10000));\n  const INPUT_FRACTION_AFTER_FEE = ONE_HUNDRED_PERCENT.subtract(BASE_FEE); // for each hop in our trade, take away the x*y=k price impact from 0.3% fees\n  // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))\n\n  const realizedLPFee = !trade ? undefined : ONE_HUNDRED_PERCENT.subtract(trade.route.pairs.reduce(currentFee => currentFee.multiply(INPUT_FRACTION_AFTER_FEE), ONE_HUNDRED_PERCENT)); // remove lp fees from price impact\n\n  const priceImpactWithoutFeeFraction = trade && realizedLPFee ? trade.priceImpact.subtract(realizedLPFee) : undefined; // the x*y=k impact\n\n  const priceImpactWithoutFeePercent = priceImpactWithoutFeeFraction ? new Percent(priceImpactWithoutFeeFraction === null || priceImpactWithoutFeeFraction === void 0 ? void 0 : priceImpactWithoutFeeFraction.numerator, priceImpactWithoutFeeFraction === null || priceImpactWithoutFeeFraction === void 0 ? void 0 : priceImpactWithoutFeeFraction.denominator) : undefined; // the amount of the input that accrues to LPs\n\n  const realizedLPFeeAmount = realizedLPFee && trade && (trade.inputAmount instanceof TokenAmount ? new TokenAmount(trade.inputAmount.token, realizedLPFee.multiply(trade.inputAmount.raw).quotient) : CurrencyAmount.ether(realizedLPFee.multiply(trade.inputAmount.raw).quotient));\n  return {\n    priceImpactWithoutFee: priceImpactWithoutFeePercent,\n    realizedLPFee: realizedLPFeeAmount\n  };\n} // get user token balance in BigNumber\n\nexport async function getUserTokenBalanceRaw(token, account, library) {\n  if (token === ETHER) {\n    return await library.getBalance(account);\n  } else {\n    let contractToCheckForBalance = getContract(token.address, ERC20ABI, library, account);\n    return await contractToCheckForBalance.balanceOf(account);\n  }\n} // get user token balance in readable string foramt\n\nexport async function getUserTokenBalance(token, chainId, account, library) {\n  let {\n    address,\n    symbol,\n    decimal\n  } = token;\n  if (!token) return;\n  let tokenIsETH = symbol === \"ETH\";\n  return formatUnits(await getUserTokenBalanceRaw(tokenIsETH ? ETHER : new Token(chainId, address, decimal, symbol), account, library), decimal);\n} // return slippage adjusted amount for arguments when adding liquidity. Returns JSBI\n\nexport function calculateSlippageAmount(value, slippage) {\n  if (slippage < 0 || slippage > 10000) {\n    throw Error(`Unexpected slippage value: ${slippage}`);\n  }\n\n  return [JSBI.divide(JSBI.multiply(value.raw, JSBI.BigInt(10000 - slippage)), JSBI.BigInt(10000)), JSBI.divide(JSBI.multiply(value.raw, JSBI.BigInt(10000 + slippage)), JSBI.BigInt(10000))];\n} // approve an ERC-20 token\n\nexport async function approve(tokenAddress, requiredAmount, library, account) {\n  if (requiredAmount === \"0\") {\n    console.log(\"Unncessary call to approve\");\n    return true;\n  }\n\n  let allowance = await getAllowance(tokenAddress, account, // owner\n  ROUTER_ADDRESS, //spender\n  library, // provider\n  account // active account\n  );\n  console.log(`ALLOWANCE FOR TOKEN ${tokenAddress}`);\n  console.log(allowance);\n  console.log(\"REquired amount\");\n  console.log(requiredAmount);\n\n  if (allowance.lt(BigNumber.from(requiredAmount))) {\n    let tokenContract = getContract(tokenAddress, ERC20ABI, library, account);\n    let useExact = false;\n    console.log(\"NOT ENOUGH ALLOWANCE\"); // try to get max allowance\n\n    let estimatedGas = await tokenContract.estimateGas[\"approve\"](ROUTER_ADDRESS, MaxUint256).catch(async () => {\n      // general fallback for tokens who restrict approval amounts\n      useExact = true;\n      let result = await tokenContract.estimateGas.approve(ROUTER_ADDRESS, requiredAmount.raw.toString());\n      return result;\n    });\n    console.log(`Exact? ${useExact}`);\n    let res = await tokenContract.approve(ROUTER_ADDRESS, useExact ? requiredAmount.raw.toString() : MaxUint256, {\n      gasLimit: calculateGasMargin(estimatedGas)\n    }).catch(() => {\n      console.log(\"not approve success\");\n      return false;\n    });\n    console.log(res);\n\n    if (res == false) {\n      return false;\n    }\n\n    let flag = false;\n\n    while (1) {\n      let newAllowance = await getAllowance(tokenAddress, account, // owner\n      ROUTER_ADDRESS, //spender\n      library, // provider\n      account // active account\n      );\n\n      if (newAllowance.gte(BigNumber.from(requiredAmount))) {\n        flag = true;\n        break;\n      }\n    }\n\n    if (flag) return true;\n  } else {\n    console.log(\"Allowance sufficient\");\n    return true;\n  }\n} // should be used in polling to check status of token approval every n seconds\n\nexport async function checkTokenIsApproved(tokenAddress, requiredAmount, library, account) {\n  let allowance = await getAllowance(tokenAddress, account, // owner\n  ROUTER_ADDRESS, //spender\n  library, // provider\n  account // active account\n  );\n  console.log(\"REQUIRED AMOUNT:\");\n  console.log(requiredAmount);\n  console.log(`ALLOWANCE FOR TOKEN ${tokenAddress}:`);\n  console.log(allowance);\n  return allowance.gte(BigNumber.from(requiredAmount));\n} // get total supply of a ERC-20 token, can be liquidity token\n\nexport async function getTokenTotalSupply(token, library, account) {\n  let tokenContract = getContract(token.address, ERC20ABI, library, account);\n  let totalSupply = await tokenContract.totalSupply();\n  let parsedResult = new TokenAmount(token, totalSupply.toString());\n  return parsedResult;\n}","map":{"version":3,"sources":["D:/GitHub/acy-dex-swap/src/utils/index.js"],"names":["abi","IUniswapV2Router02ABI","IUniswapV2PairABI","ERC20ABI","getAddress","Contract","AddressZero","BigNumber","parseUnits","formatUnits","JSBI","Token","TokenAmount","TradeType","Route","Trade","Fetcher","Percent","WETH","ETHER","CurrencyAmount","InsufficientReservesError","MaxUint256","INITIAL_ALLOWED_SLIPPAGE","ROUTER_ADDRESS","supportedTokens","symbol","address","decimal","isAddress","value","getSigner","library","account","connectUnchecked","getProviderOrSigner","getContract","ABI","Error","getRouterContract","getPairContract","pairAddress","calculateGasMargin","console","log","mul","from","add","div","isZero","hexNumberString","test","getAllowance","tokenAddress","owner","spender","tokenContract","allowance","ACYSwapErrorStatus","getErrorText","errorText","constructor","computeTradePriceBreakdown","trade","BASE_FEE","BigInt","ONE_HUNDRED_PERCENT","INPUT_FRACTION_AFTER_FEE","subtract","realizedLPFee","undefined","route","pairs","reduce","currentFee","multiply","priceImpactWithoutFeeFraction","priceImpact","priceImpactWithoutFeePercent","numerator","denominator","realizedLPFeeAmount","inputAmount","token","raw","quotient","ether","priceImpactWithoutFee","getUserTokenBalanceRaw","getBalance","contractToCheckForBalance","balanceOf","getUserTokenBalance","chainId","tokenIsETH","calculateSlippageAmount","slippage","divide","approve","requiredAmount","lt","useExact","estimatedGas","estimateGas","catch","result","toString","res","gasLimit","flag","newAllowance","gte","checkTokenIsApproved","getTokenTotalSupply","totalSupply","parsedResult"],"mappings":"AAAA,SAASA,GAAG,IAAIC,qBAAhB,QAA6C,iCAA7C;AACA,SAASD,GAAG,IAAIE,iBAAhB,QAAyC,4CAAzC;AACA,OAAOC,QAAP,MAAqB,oBAArB;AACA,SAASC,UAAT,QAA2B,wBAA3B;AACA,SAASC,QAAT,QAAyB,0BAAzB;AACA,SAASC,WAAT,QAA4B,0BAA5B;AACA,SAASC,SAAT,QAA0B,0BAA1B;AACA,SAASC,UAAT,EAAqBC,WAArB,QAAwC,sBAAxC;AACA,SACEC,IADF,EAEEC,KAFF,EAGEC,WAHF,EAIEC,SAJF,EAKEC,KALF,EAMEC,KANF,EAOEC,OAPF,EAQEC,OARF,EASEC,IATF,EAUEC,KAVF,EAWEC,cAXF,EAYEC,yBAZF,QAaO,cAbP;AAcA,SAASC,UAAT,QAA2B,0BAA3B;AAEA,OAAO,MAAMC,wBAAwB,GAAG,EAAjC,C,CAAqC;;AAE5C,OAAO,MAAMC,cAAc,GAAG,4CAAvB,C,CACP;;AAEA,OAAO,MAAMC,eAAe,GAAG,CAC7B;AACEC,EAAAA,MAAM,EAAE,MADV;AAEEC,EAAAA,OAAO,EAAE,4CAFX;AAGEC,EAAAA,OAAO,EAAE;AAHX,CAD6B,EAM7B;AACEF,EAAAA,MAAM,EAAE,KADV;AAEEC,EAAAA,OAAO,EAAE,4CAFX;AAGEC,EAAAA,OAAO,EAAE;AAHX,CAN6B,EAW7B;AACEF,EAAAA,MAAM,EAAE,MADV;AAEEC,EAAAA,OAAO,EAAE,4CAFX;AAGEC,EAAAA,OAAO,EAAE;AAHX,CAX6B,EAgB7B;AACEF,EAAAA,MAAM,EAAE,MADV;AAEEC,EAAAA,OAAO,EAAE,4CAFX;AAGEC,EAAAA,OAAO,EAAE;AAHX,CAhB6B,CAAxB;AAuBP,OAAO,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AAC/B,MAAI;AACF,WAAO1B,UAAU,CAAC0B,KAAD,CAAjB;AACD,GAFD,CAEE,MAAM;AACN,WAAO,KAAP;AACD;AACF,C,CAED;;AACA,OAAO,SAASC,SAAT,CAAmBC,OAAnB,EAA4BC,OAA5B,EAAqC;AAC1C,SAAOD,OAAO,CAACD,SAAR,CAAkBE,OAAlB,EAA2BC,gBAA3B,EAAP;AACD,C,CAED;;AACA,OAAO,SAASC,mBAAT,CAA6BH,OAA7B,EAAsCC,OAAtC,EAA+C;AACpD,SAAOA,OAAO,GAAGF,SAAS,CAACC,OAAD,EAAUC,OAAV,CAAZ,GAAiCD,OAA/C;AACD,C,CAED;;AACA,OAAO,SAASI,WAAT,CAAqBT,OAArB,EAA8BU,GAA9B,EAAmCL,OAAnC,EAA4CC,OAA5C,EAAqD;AAC1D,MAAI,CAACJ,SAAS,CAACF,OAAD,CAAV,IAAuBA,OAAO,KAAKrB,WAAvC,EAAoD;AAClD,UAAMgC,KAAK,CAAE,gCAA+BX,OAAQ,IAAzC,CAAX;AACD;;AAED,SAAO,IAAItB,QAAJ,CAAasB,OAAb,EAAsBU,GAAtB,EAA2BF,mBAAmB,CAACH,OAAD,EAAUC,OAAV,CAA9C,CAAP;AACD;AAED,OAAO,SAASM,iBAAT,CAA2BP,OAA3B,EAAoCC,OAApC,EAA6C;AAClD,SAAOG,WAAW,CAACZ,cAAD,EAAiBvB,qBAAjB,EAAwC+B,OAAxC,EAAiDC,OAAjD,CAAlB;AACD;AAED,OAAO,SAASO,eAAT,CAAyBC,WAAzB,EAAsCT,OAAtC,EAA+CC,OAA/C,EAAwD;AAC7D,SAAOG,WAAW,CAACK,WAAD,EAAcvC,iBAAd,EAAiC8B,OAAjC,EAA0CC,OAA1C,CAAlB;AACD,C,CAED;;AACA,OAAO,SAASS,kBAAT,CAA4BZ,KAA5B,EAAmC;AACxCa,EAAAA,OAAO,CAACC,GAAR,CAAY,yBAAZ;AACA,SAAOd,KAAK,CACTe,GADI,CACAtC,SAAS,CAACuC,IAAV,CAAe,KAAf,EAAsBC,GAAtB,CAA0BxC,SAAS,CAACuC,IAAV,CAAe,IAAf,CAA1B,CADA,EAEJE,GAFI,CAEAzC,SAAS,CAACuC,IAAV,CAAe,KAAf,CAFA,CAAP;AAGD,C,CAED;;AACA,OAAO,SAASG,MAAT,CAAgBC,eAAhB,EAAiC;AACtC,SAAO,SAASC,IAAT,CAAcD,eAAd,CAAP;AACD,C,CAED;;AACA,OAAO,eAAeE,YAAf,CACLC,YADK,EAELC,KAFK,EAGLC,OAHK,EAILvB,OAJK,EAKLC,OALK,EAML;AACA,MAAIuB,aAAa,GAAGpB,WAAW,CAACiB,YAAD,EAAelD,QAAf,EAAyB6B,OAAzB,EAAkCC,OAAlC,CAA/B;AACA,MAAIwB,SAAS,GAAG,MAAMD,aAAa,CAACC,SAAd,CAAwBH,KAAxB,EAA+BC,OAA/B,CAAtB;AACAZ,EAAAA,OAAO,CAACC,GAAR,CAAYa,SAAZ;AACA,SAAOA,SAAP;AACD,C,CAED;;AACA,OAAO,MAAMC,kBAAN,CAAyB;AAC9BC,EAAAA,YAAY,GAAG;AACb,WAAO,KAAKC,SAAZ;AACD;;AACDC,EAAAA,WAAW,CAACD,SAAD,EAAY;AACrB,SAAKA,SAAL,GAAiBA,SAAjB;AACD;;AAN6B,C,CAShC;;AACA,OAAO,SAASE,0BAAT,CAAoCC,KAApC,EAA2C;AAChD,QAAMC,QAAQ,GAAG,IAAI/C,OAAJ,CAAYP,IAAI,CAACuD,MAAL,CAAY,EAAZ,CAAZ,EAA6BvD,IAAI,CAACuD,MAAL,CAAY,KAAZ,CAA7B,CAAjB;AACA,QAAMC,mBAAmB,GAAG,IAAIjD,OAAJ,CAC1BP,IAAI,CAACuD,MAAL,CAAY,KAAZ,CAD0B,EAE1BvD,IAAI,CAACuD,MAAL,CAAY,KAAZ,CAF0B,CAA5B;AAIA,QAAME,wBAAwB,GAAGD,mBAAmB,CAACE,QAApB,CAA6BJ,QAA7B,CAAjC,CANgD,CAQhD;AACA;;AACA,QAAMK,aAAa,GAAG,CAACN,KAAD,GAClBO,SADkB,GAElBJ,mBAAmB,CAACE,QAApB,CACEL,KAAK,CAACQ,KAAN,CAAYC,KAAZ,CAAkBC,MAAlB,CACGC,UAAD,IAAgBA,UAAU,CAACC,QAAX,CAAoBR,wBAApB,CADlB,EAEED,mBAFF,CADF,CAFJ,CAVgD,CAmBhD;;AACA,QAAMU,6BAA6B,GACjCb,KAAK,IAAIM,aAAT,GACIN,KAAK,CAACc,WAAN,CAAkBT,QAAlB,CAA2BC,aAA3B,CADJ,GAEIC,SAHN,CApBgD,CAyBhD;;AACA,QAAMQ,4BAA4B,GAAGF,6BAA6B,GAC9D,IAAI3D,OAAJ,CACE2D,6BADF,aACEA,6BADF,uBACEA,6BAA6B,CAAEG,SADjC,EAEEH,6BAFF,aAEEA,6BAFF,uBAEEA,6BAA6B,CAAEI,WAFjC,CAD8D,GAK9DV,SALJ,CA1BgD,CAiChD;;AACA,QAAMW,mBAAmB,GACvBZ,aAAa,IACbN,KADA,KAECA,KAAK,CAACmB,WAAN,YAA6BtE,WAA7B,GACG,IAAIA,WAAJ,CACEmD,KAAK,CAACmB,WAAN,CAAkBC,KADpB,EAEEd,aAAa,CAACM,QAAd,CAAuBZ,KAAK,CAACmB,WAAN,CAAkBE,GAAzC,EAA8CC,QAFhD,CADH,GAKGjE,cAAc,CAACkE,KAAf,CACEjB,aAAa,CAACM,QAAd,CAAuBZ,KAAK,CAACmB,WAAN,CAAkBE,GAAzC,EAA8CC,QADhD,CAPJ,CADF;AAYA,SAAO;AACLE,IAAAA,qBAAqB,EAAET,4BADlB;AAELT,IAAAA,aAAa,EAAEY;AAFV,GAAP;AAID,C,CAED;;AACA,OAAO,eAAeO,sBAAf,CAAsCL,KAAtC,EAA6ClD,OAA7C,EAAsDD,OAAtD,EAA+D;AACpE,MAAImD,KAAK,KAAKhE,KAAd,EAAqB;AACnB,WAAO,MAAMa,OAAO,CAACyD,UAAR,CAAmBxD,OAAnB,CAAb;AACD,GAFD,MAEO;AACL,QAAIyD,yBAAyB,GAAGtD,WAAW,CACzC+C,KAAK,CAACxD,OADmC,EAEzCxB,QAFyC,EAGzC6B,OAHyC,EAIzCC,OAJyC,CAA3C;AAMA,WAAO,MAAMyD,yBAAyB,CAACC,SAA1B,CAAoC1D,OAApC,CAAb;AACD;AACF,C,CAED;;AACA,OAAO,eAAe2D,mBAAf,CAAmCT,KAAnC,EAA0CU,OAA1C,EAAmD5D,OAAnD,EAA4DD,OAA5D,EAAqE;AAC1E,MAAI;AAAEL,IAAAA,OAAF;AAAWD,IAAAA,MAAX;AAAmBE,IAAAA;AAAnB,MAA+BuD,KAAnC;AAEA,MAAI,CAACA,KAAL,EAAY;AACZ,MAAIW,UAAU,GAAGpE,MAAM,KAAK,KAA5B;AAEA,SAAOjB,WAAW,CAChB,MAAM+E,sBAAsB,CAC1BM,UAAU,GAAG3E,KAAH,GAAW,IAAIR,KAAJ,CAAUkF,OAAV,EAAmBlE,OAAnB,EAA4BC,OAA5B,EAAqCF,MAArC,CADK,EAE1BO,OAF0B,EAG1BD,OAH0B,CADZ,EAMhBJ,OANgB,CAAlB;AAQD,C,CAED;;AACA,OAAO,SAASmE,uBAAT,CAAiCjE,KAAjC,EAAwCkE,QAAxC,EAAkD;AACvD,MAAIA,QAAQ,GAAG,CAAX,IAAgBA,QAAQ,GAAG,KAA/B,EAAsC;AACpC,UAAM1D,KAAK,CAAE,8BAA6B0D,QAAS,EAAxC,CAAX;AACD;;AACD,SAAO,CACLtF,IAAI,CAACuF,MAAL,CACEvF,IAAI,CAACiE,QAAL,CAAc7C,KAAK,CAACsD,GAApB,EAAyB1E,IAAI,CAACuD,MAAL,CAAY,QAAQ+B,QAApB,CAAzB,CADF,EAEEtF,IAAI,CAACuD,MAAL,CAAY,KAAZ,CAFF,CADK,EAKLvD,IAAI,CAACuF,MAAL,CACEvF,IAAI,CAACiE,QAAL,CAAc7C,KAAK,CAACsD,GAApB,EAAyB1E,IAAI,CAACuD,MAAL,CAAY,QAAQ+B,QAApB,CAAzB,CADF,EAEEtF,IAAI,CAACuD,MAAL,CAAY,KAAZ,CAFF,CALK,CAAP;AAUD,C,CAED;;AACA,OAAO,eAAeiC,OAAf,CAAuB7C,YAAvB,EAAqC8C,cAArC,EAAqDnE,OAArD,EAA8DC,OAA9D,EAAuE;AAC5E,MAAIkE,cAAc,KAAK,GAAvB,EAA4B;AAC1BxD,IAAAA,OAAO,CAACC,GAAR,CAAY,4BAAZ;AACA,WAAO,IAAP;AACD;;AAED,MAAIa,SAAS,GAAG,MAAML,YAAY,CAChCC,YADgC,EAEhCpB,OAFgC,EAEvB;AACTT,EAAAA,cAHgC,EAGhB;AAChBQ,EAAAA,OAJgC,EAIvB;AACTC,EAAAA,OALgC,CAKxB;AALwB,GAAlC;AAQAU,EAAAA,OAAO,CAACC,GAAR,CAAa,uBAAsBS,YAAa,EAAhD;AACAV,EAAAA,OAAO,CAACC,GAAR,CAAYa,SAAZ;AAEAd,EAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACAD,EAAAA,OAAO,CAACC,GAAR,CAAYuD,cAAZ;;AACA,MAAI1C,SAAS,CAAC2C,EAAV,CAAa7F,SAAS,CAACuC,IAAV,CAAeqD,cAAf,CAAb,CAAJ,EAAkD;AAChD,QAAI3C,aAAa,GAAGpB,WAAW,CAACiB,YAAD,EAAelD,QAAf,EAAyB6B,OAAzB,EAAkCC,OAAlC,CAA/B;AACA,QAAIoE,QAAQ,GAAG,KAAf;AACA1D,IAAAA,OAAO,CAACC,GAAR,CAAY,sBAAZ,EAHgD,CAIhD;;AACA,QAAI0D,YAAY,GAAG,MAAM9C,aAAa,CAAC+C,WAAd,CAA0B,SAA1B,EACvB/E,cADuB,EAEvBF,UAFuB,EAGvBkF,KAHuB,CAGjB,YAAY;AAClB;AACAH,MAAAA,QAAQ,GAAG,IAAX;AACA,UAAII,MAAM,GAAG,MAAMjD,aAAa,CAAC+C,WAAd,CAA0BL,OAA1B,CACjB1E,cADiB,EAEjB2E,cAAc,CAACf,GAAf,CAAmBsB,QAAnB,EAFiB,CAAnB;AAIA,aAAOD,MAAP;AACD,KAXwB,CAAzB;AAaA9D,IAAAA,OAAO,CAACC,GAAR,CAAa,UAASyD,QAAS,EAA/B;AACA,QAAIM,GAAG,GAAG,MAAMnD,aAAa,CAC1B0C,OADa,CAEZ1E,cAFY,EAGZ6E,QAAQ,GAAGF,cAAc,CAACf,GAAf,CAAmBsB,QAAnB,EAAH,GAAmCpF,UAH/B,EAIZ;AACEsF,MAAAA,QAAQ,EAAElE,kBAAkB,CAAC4D,YAAD;AAD9B,KAJY,EAQbE,KARa,CAQP,MAAM;AACX7D,MAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ;AACA,aAAO,KAAP;AACD,KAXa,CAAhB;AAYAD,IAAAA,OAAO,CAACC,GAAR,CAAY+D,GAAZ;;AAEA,QAAIA,GAAG,IAAI,KAAX,EAAkB;AAChB,aAAO,KAAP;AACD;;AAED,QAAIE,IAAI,GAAG,KAAX;;AAEA,WAAO,CAAP,EAAU;AACR,UAAIC,YAAY,GAAG,MAAM1D,YAAY,CACnCC,YADmC,EAEnCpB,OAFmC,EAE1B;AACTT,MAAAA,cAHmC,EAGnB;AAChBQ,MAAAA,OAJmC,EAI1B;AACTC,MAAAA,OALmC,CAK3B;AAL2B,OAArC;;AAQA,UAAI6E,YAAY,CAACC,GAAb,CAAiBxG,SAAS,CAACuC,IAAV,CAAeqD,cAAf,CAAjB,CAAJ,EAAsD;AACpDU,QAAAA,IAAI,GAAG,IAAP;AACA;AACD;AACF;;AACD,QAAIA,IAAJ,EAAU,OAAO,IAAP;AACX,GAtDD,MAsDO;AACLlE,IAAAA,OAAO,CAACC,GAAR,CAAY,sBAAZ;AACA,WAAO,IAAP;AACD;AACF,C,CAED;;AACA,OAAO,eAAeoE,oBAAf,CACL3D,YADK,EAEL8C,cAFK,EAGLnE,OAHK,EAILC,OAJK,EAKL;AACA,MAAIwB,SAAS,GAAG,MAAML,YAAY,CAChCC,YADgC,EAEhCpB,OAFgC,EAEvB;AACTT,EAAAA,cAHgC,EAGhB;AAChBQ,EAAAA,OAJgC,EAIvB;AACTC,EAAAA,OALgC,CAKxB;AALwB,GAAlC;AAQAU,EAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AACAD,EAAAA,OAAO,CAACC,GAAR,CAAYuD,cAAZ;AACAxD,EAAAA,OAAO,CAACC,GAAR,CAAa,uBAAsBS,YAAa,GAAhD;AACAV,EAAAA,OAAO,CAACC,GAAR,CAAYa,SAAZ;AACA,SAAOA,SAAS,CAACsD,GAAV,CAAcxG,SAAS,CAACuC,IAAV,CAAeqD,cAAf,CAAd,CAAP;AACD,C,CAED;;AACA,OAAO,eAAec,mBAAf,CAAmC9B,KAAnC,EAA0CnD,OAA1C,EAAmDC,OAAnD,EAA4D;AACjE,MAAIuB,aAAa,GAAGpB,WAAW,CAAC+C,KAAK,CAACxD,OAAP,EAAgBxB,QAAhB,EAA0B6B,OAA1B,EAAmCC,OAAnC,CAA/B;AACA,MAAIiF,WAAW,GAAG,MAAM1D,aAAa,CAAC0D,WAAd,EAAxB;AACA,MAAIC,YAAY,GAAG,IAAIvG,WAAJ,CAAgBuE,KAAhB,EAAuB+B,WAAW,CAACR,QAAZ,EAAvB,CAAnB;AAEA,SAAOS,YAAP;AACD","sourcesContent":["import { abi as IUniswapV2Router02ABI } from \"../abis/IUniswapV2Router02.json\";\r\nimport { abi as IUniswapV2PairABI } from \"@uniswap/v2-core/build/IUniswapV2Pair.json\";\r\nimport ERC20ABI from \"../abis/ERC20.json\";\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { Contract } from \"@ethersproject/contracts\";\r\nimport { AddressZero } from \"@ethersproject/constants\";\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { parseUnits, formatUnits } from \"@ethersproject/units\";\r\nimport {\r\n  JSBI,\r\n  Token,\r\n  TokenAmount,\r\n  TradeType,\r\n  Route,\r\n  Trade,\r\n  Fetcher,\r\n  Percent,\r\n  WETH,\r\n  ETHER,\r\n  CurrencyAmount,\r\n  InsufficientReservesError,\r\n} from \"@uniswap/sdk\";\r\nimport { MaxUint256 } from \"@ethersproject/constants\";\r\n\r\nexport const INITIAL_ALLOWED_SLIPPAGE = 50; //bips\r\n\r\nexport const ROUTER_ADDRESS = \"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\";\r\n// export const ROUTER_ADDRESS = \"0xF3726d6acfeda3E73a6F2328b948834f3Af39A2B\";\r\n\r\nexport const supportedTokens = [\r\n  {\r\n    symbol: \"USDC\",\r\n    address: \"0x4DBCdF9B62e891a7cec5A2568C3F4FAF9E8Abe2b\",\r\n    decimal: 6,\r\n  },\r\n  {\r\n    symbol: \"ETH\",\r\n    address: \"0xc778417E063141139Fce010982780140Aa0cD5Ab\",\r\n    decimal: 18,\r\n  },\r\n  {\r\n    symbol: \"TEST\",\r\n    address: \"0xAEd3ed6cF66E1CB13ab8DC312a0dC91bc0936721\",\r\n    decimal: 18,\r\n  },\r\n  {\r\n    symbol: \"WBTC\",\r\n    address: \"0x577d296678535e4903d59a4c929b718e1d575e0a\",\r\n    decimal: 8,\r\n  },\r\n];\r\n\r\nexport function isAddress(value) {\r\n  try {\r\n    return getAddress(value);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n// account is not optional\r\nexport function getSigner(library, account) {\r\n  return library.getSigner(account).connectUnchecked();\r\n}\r\n\r\n// account is optional\r\nexport function getProviderOrSigner(library, account) {\r\n  return account ? getSigner(library, account) : library;\r\n}\r\n\r\n// account is optional\r\nexport function getContract(address, ABI, library, account) {\r\n  if (!isAddress(address) || address === AddressZero) {\r\n    throw Error(`Invalid 'address' parameter '${address}'.`);\r\n  }\r\n\r\n  return new Contract(address, ABI, getProviderOrSigner(library, account));\r\n}\r\n\r\nexport function getRouterContract(library, account) {\r\n  return getContract(ROUTER_ADDRESS, IUniswapV2Router02ABI, library, account);\r\n}\r\n\r\nexport function getPairContract(pairAddress, library, account) {\r\n  return getContract(pairAddress, IUniswapV2PairABI, library, account);\r\n}\r\n\r\n// return gas with 10% added margin in BigNumber\r\nexport function calculateGasMargin(value) {\r\n  console.log(\"just calculateGasMargin\");\r\n  return value\r\n    .mul(BigNumber.from(10000).add(BigNumber.from(1000)))\r\n    .div(BigNumber.from(10000));\r\n}\r\n\r\n// check if hex string is zero\r\nexport function isZero(hexNumberString) {\r\n  return /^0x0*$/.test(hexNumberString);\r\n}\r\n\r\n// return token allowance in BigNumber\r\nexport async function getAllowance(\r\n  tokenAddress,\r\n  owner,\r\n  spender,\r\n  library,\r\n  account\r\n) {\r\n  let tokenContract = getContract(tokenAddress, ERC20ABI, library, account);\r\n  let allowance = await tokenContract.allowance(owner, spender);\r\n  console.log(allowance);\r\n  return allowance;\r\n}\r\n\r\n// a custom error class for custom error text and handling\r\nexport class ACYSwapErrorStatus {\r\n  getErrorText() {\r\n    return this.errorText;\r\n  }\r\n  constructor(errorText) {\r\n    this.errorText = errorText;\r\n  }\r\n}\r\n\r\n// taken from Uniswap, used for price impact and realized liquid provider fee\r\nexport function computeTradePriceBreakdown(trade) {\r\n  const BASE_FEE = new Percent(JSBI.BigInt(30), JSBI.BigInt(10000));\r\n  const ONE_HUNDRED_PERCENT = new Percent(\r\n    JSBI.BigInt(10000),\r\n    JSBI.BigInt(10000)\r\n  );\r\n  const INPUT_FRACTION_AFTER_FEE = ONE_HUNDRED_PERCENT.subtract(BASE_FEE);\r\n\r\n  // for each hop in our trade, take away the x*y=k price impact from 0.3% fees\r\n  // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))\r\n  const realizedLPFee = !trade\r\n    ? undefined\r\n    : ONE_HUNDRED_PERCENT.subtract(\r\n        trade.route.pairs.reduce(\r\n          (currentFee) => currentFee.multiply(INPUT_FRACTION_AFTER_FEE),\r\n          ONE_HUNDRED_PERCENT\r\n        )\r\n      );\r\n\r\n  // remove lp fees from price impact\r\n  const priceImpactWithoutFeeFraction =\r\n    trade && realizedLPFee\r\n      ? trade.priceImpact.subtract(realizedLPFee)\r\n      : undefined;\r\n\r\n  // the x*y=k impact\r\n  const priceImpactWithoutFeePercent = priceImpactWithoutFeeFraction\r\n    ? new Percent(\r\n        priceImpactWithoutFeeFraction?.numerator,\r\n        priceImpactWithoutFeeFraction?.denominator\r\n      )\r\n    : undefined;\r\n\r\n  // the amount of the input that accrues to LPs\r\n  const realizedLPFeeAmount =\r\n    realizedLPFee &&\r\n    trade &&\r\n    (trade.inputAmount instanceof TokenAmount\r\n      ? new TokenAmount(\r\n          trade.inputAmount.token,\r\n          realizedLPFee.multiply(trade.inputAmount.raw).quotient\r\n        )\r\n      : CurrencyAmount.ether(\r\n          realizedLPFee.multiply(trade.inputAmount.raw).quotient\r\n        ));\r\n\r\n  return {\r\n    priceImpactWithoutFee: priceImpactWithoutFeePercent,\r\n    realizedLPFee: realizedLPFeeAmount,\r\n  };\r\n}\r\n\r\n// get user token balance in BigNumber\r\nexport async function getUserTokenBalanceRaw(token, account, library) {\r\n  if (token === ETHER) {\r\n    return await library.getBalance(account);\r\n  } else {\r\n    let contractToCheckForBalance = getContract(\r\n      token.address,\r\n      ERC20ABI,\r\n      library,\r\n      account\r\n    );\r\n    return await contractToCheckForBalance.balanceOf(account);\r\n  }\r\n}\r\n\r\n// get user token balance in readable string foramt\r\nexport async function getUserTokenBalance(token, chainId, account, library) {\r\n  let { address, symbol, decimal } = token;\r\n\r\n  if (!token) return;\r\n  let tokenIsETH = symbol === \"ETH\";\r\n\r\n  return formatUnits(\r\n    await getUserTokenBalanceRaw(\r\n      tokenIsETH ? ETHER : new Token(chainId, address, decimal, symbol),\r\n      account,\r\n      library\r\n    ),\r\n    decimal\r\n  );\r\n}\r\n\r\n// return slippage adjusted amount for arguments when adding liquidity. Returns JSBI\r\nexport function calculateSlippageAmount(value, slippage) {\r\n  if (slippage < 0 || slippage > 10000) {\r\n    throw Error(`Unexpected slippage value: ${slippage}`);\r\n  }\r\n  return [\r\n    JSBI.divide(\r\n      JSBI.multiply(value.raw, JSBI.BigInt(10000 - slippage)),\r\n      JSBI.BigInt(10000)\r\n    ),\r\n    JSBI.divide(\r\n      JSBI.multiply(value.raw, JSBI.BigInt(10000 + slippage)),\r\n      JSBI.BigInt(10000)\r\n    ),\r\n  ];\r\n}\r\n\r\n// approve an ERC-20 token\r\nexport async function approve(tokenAddress, requiredAmount, library, account) {\r\n  if (requiredAmount === \"0\") {\r\n    console.log(\"Unncessary call to approve\");\r\n    return true;\r\n  }\r\n\r\n  let allowance = await getAllowance(\r\n    tokenAddress,\r\n    account, // owner\r\n    ROUTER_ADDRESS, //spender\r\n    library, // provider\r\n    account // active account\r\n  );\r\n\r\n  console.log(`ALLOWANCE FOR TOKEN ${tokenAddress}`);\r\n  console.log(allowance);\r\n\r\n  console.log(\"REquired amount\");\r\n  console.log(requiredAmount);\r\n  if (allowance.lt(BigNumber.from(requiredAmount))) {\r\n    let tokenContract = getContract(tokenAddress, ERC20ABI, library, account);\r\n    let useExact = false;\r\n    console.log(\"NOT ENOUGH ALLOWANCE\");\r\n    // try to get max allowance\r\n    let estimatedGas = await tokenContract.estimateGas[\"approve\"](\r\n      ROUTER_ADDRESS,\r\n      MaxUint256\r\n    ).catch(async () => {\r\n      // general fallback for tokens who restrict approval amounts\r\n      useExact = true;\r\n      let result = await tokenContract.estimateGas.approve(\r\n        ROUTER_ADDRESS,\r\n        requiredAmount.raw.toString()\r\n      );\r\n      return result;\r\n    });\r\n\r\n    console.log(`Exact? ${useExact}`);\r\n    let res = await tokenContract\r\n      .approve(\r\n        ROUTER_ADDRESS,\r\n        useExact ? requiredAmount.raw.toString() : MaxUint256,\r\n        {\r\n          gasLimit: calculateGasMargin(estimatedGas),\r\n        }\r\n      )\r\n      .catch(() => {\r\n        console.log(\"not approve success\");\r\n        return false;\r\n      });\r\n    console.log(res);\r\n\r\n    if (res == false) {\r\n      return false;\r\n    }\r\n\r\n    let flag = false;\r\n\r\n    while (1) {\r\n      let newAllowance = await getAllowance(\r\n        tokenAddress,\r\n        account, // owner\r\n        ROUTER_ADDRESS, //spender\r\n        library, // provider\r\n        account // active account\r\n      );\r\n\r\n      if (newAllowance.gte(BigNumber.from(requiredAmount))) {\r\n        flag = true;\r\n        break;\r\n      }\r\n    }\r\n    if (flag) return true;\r\n  } else {\r\n    console.log(\"Allowance sufficient\");\r\n    return true;\r\n  }\r\n}\r\n\r\n// should be used in polling to check status of token approval every n seconds\r\nexport async function checkTokenIsApproved(\r\n  tokenAddress,\r\n  requiredAmount,\r\n  library,\r\n  account\r\n) {\r\n  let allowance = await getAllowance(\r\n    tokenAddress,\r\n    account, // owner\r\n    ROUTER_ADDRESS, //spender\r\n    library, // provider\r\n    account // active account\r\n  );\r\n\r\n  console.log(\"REQUIRED AMOUNT:\");\r\n  console.log(requiredAmount);\r\n  console.log(`ALLOWANCE FOR TOKEN ${tokenAddress}:`);\r\n  console.log(allowance);\r\n  return allowance.gte(BigNumber.from(requiredAmount));\r\n}\r\n\r\n// get total supply of a ERC-20 token, can be liquidity token\r\nexport async function getTokenTotalSupply(token, library, account) {\r\n  let tokenContract = getContract(token.address, ERC20ABI, library, account);\r\n  let totalSupply = await tokenContract.totalSupply();\r\n  let parsedResult = new TokenAmount(token, totalSupply.toString());\r\n\r\n  return parsedResult;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}