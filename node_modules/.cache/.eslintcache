[{"D:\\GitHub\\acy-dex-swap\\src\\index.js":"1","D:\\GitHub\\acy-dex-swap\\src\\reportWebVitals.js":"2","D:\\GitHub\\acy-dex-swap\\src\\App.js":"3","D:\\GitHub\\acy-dex-swap\\src\\components\\SwapComponent.js":"4","D:\\GitHub\\acy-dex-swap\\src\\components\\LiquidityComponent.js":"5","D:\\GitHub\\acy-dex-swap\\src\\components\\RemoveLiquidityComponent.js":"6","D:\\GitHub\\acy-dex-swap\\src\\utils\\index.js":"7","D:\\GitHub\\acy-dex-swap\\src\\components\\Navbar.jsx":"8","D:\\GitHub\\acy-dex-swap\\src\\components\\NotFound.jsx":"9","D:\\GitHub\\acy-dex-swap\\src\\components\\Home.jsx":"10","D:\\GitHub\\acy-dex-swap\\src\\components\\Transaction.jsx":"11","D:\\GitHub\\acy-dex-swap\\src\\components\\Liquidity.jsx":"12"},{"size":517,"mtime":1644392849270,"results":"13","hashOfConfig":"14"},{"size":375,"mtime":1644392849271,"results":"15","hashOfConfig":"14"},{"size":883,"mtime":1644418456140,"results":"16","hashOfConfig":"14"},{"size":41091,"mtime":1644392849269,"results":"17","hashOfConfig":"14"},{"size":51070,"mtime":1644392849268,"results":"18","hashOfConfig":"14"},{"size":50720,"mtime":1644392849269,"results":"19","hashOfConfig":"14"},{"size":9369,"mtime":1644404866689,"results":"20","hashOfConfig":"14"},{"size":481,"mtime":1644418478707,"results":"21","hashOfConfig":"14"},{"size":161,"mtime":1644415161859,"results":"22","hashOfConfig":"14"},{"size":784,"mtime":1644418427671,"results":"23","hashOfConfig":"14"},{"size":745,"mtime":1644417673895,"results":"24","hashOfConfig":"14"},{"size":876,"mtime":1644417662356,"results":"25","hashOfConfig":"14"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"w43ril",{"filePath":"29","messages":"30","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"31","messages":"32","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"33","messages":"34","errorCount":0,"warningCount":15,"fixableErrorCount":0,"fixableWarningCount":0,"source":"35","usedDeprecatedRules":"28"},{"filePath":"36","messages":"37","errorCount":0,"warningCount":22,"fixableErrorCount":0,"fixableWarningCount":0,"source":"38","usedDeprecatedRules":"28"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":27,"fixableErrorCount":0,"fixableWarningCount":2,"source":"41","usedDeprecatedRules":"28"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"44","usedDeprecatedRules":"28"},{"filePath":"45","messages":"46","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"51","messages":"52","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"53","messages":"54","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"D:\\GitHub\\acy-dex-swap\\src\\index.js",[],["55","56"],"D:\\GitHub\\acy-dex-swap\\src\\reportWebVitals.js",[],"D:\\GitHub\\acy-dex-swap\\src\\App.js",["57"],"D:\\GitHub\\acy-dex-swap\\src\\components\\SwapComponent.js",["58","59","60","61","62","63","64","65","66","67","68","69","70","71","72"],"import {useWeb3React} from \"@web3-react/core\";\r\nimport {InjectedConnector} from \"@web3-react/injected-connector\";\r\nimport {useCallback, useEffect, useState} from \"react\";\r\nimport {\r\n    ACYSwapErrorStatus,\r\n    approve,\r\n    calculateGasMargin,\r\n    checkTokenIsApproved,\r\n    computeTradePriceBreakdown,\r\n    getAllowance,\r\n    getContract,\r\n    getRouterContract,\r\n    getUserTokenBalance,\r\n    getUserTokenBalanceRaw,\r\n    INITIAL_ALLOWED_SLIPPAGE,\r\n    isZero,\r\n    ROUTER_ADDRESS,\r\n    supportedTokens,\r\n} from \"../utils\";\r\n\r\nimport {Alert, Button, Dropdown, Form, FormControl, InputGroup} from \"react-bootstrap\";\r\n\r\nimport WETHABI from \"../abis/WETH.json\";\r\n\r\nimport {\r\n    CurrencyAmount,\r\n    ETHER,\r\n    FACTORY_ADDRESS,\r\n    Fetcher,\r\n    InsufficientReservesError,\r\n    Pair,\r\n    Percent,\r\n    Route,\r\n    Router,\r\n    Token,\r\n    TokenAmount,\r\n    Trade,\r\n    TradeType,\r\n    WETH,\r\n} from \"@uniswap/sdk\";\r\n\r\nimport {BigNumber} from \"@ethersproject/bignumber\";\r\nimport {parseUnits} from \"@ethersproject/units\";\r\n\r\n// get the estimated amount  of the other token required when swapping, in readable string.\r\nexport async function swapGetEstimated(\r\n    inputToken0,\r\n    inputToken1,\r\n    allowedSlippage = INITIAL_ALLOWED_SLIPPAGE,\r\n    exactIn = true,\r\n    chainId,\r\n    library,\r\n    account,\r\n    setToken0Amount,\r\n    setToken1Amount,\r\n    setNeedApprove,\r\n    setApproveAmount,\r\n    setApproveButtonStatus,\r\n    setSwapBreakdown,\r\n    setSwapButtonState,\r\n    setSwapButtonContent,\r\n    setSwapStatus,\r\n    setPair,\r\n    setRoute,\r\n    setTrade,\r\n    setSlippageAdjustedAmount,\r\n    setMinAmountOut,\r\n    setMaxAmountIn,\r\n    setWethContract,\r\n    setWrappedAmount\r\n)\r\n{\r\n    let status = await (async () => {\r\n        // check uniswap\r\n        console.log(FACTORY_ADDRESS);\r\n        // change slippage from bips (0.01%) into percentage\r\n        let slippage = allowedSlippage * 0.01;\r\n        allowedSlippage = new Percent(allowedSlippage, 10000);\r\n        setSwapBreakdown(\"\");\r\n        setSwapButtonState(false);\r\n        setSwapButtonContent(\"loading...\");\r\n        setSwapStatus(\"\");\r\n\r\n        let contract = getRouterContract(library, account);\r\n        let {\r\n            address: inToken0Address,\r\n            symbol: inToken0Symbol,\r\n            decimal: inToken0Decimal,\r\n            amount: inToken0Amount,\r\n        } = inputToken0;\r\n        let {\r\n            address: inToken1Address,\r\n            symbol: inToken1Symbol,\r\n            decimal: inToken1Decimal,\r\n            amount: inToken1Amount,\r\n        } = inputToken1;\r\n\r\n        if (!inputToken0.symbol || !inputToken1.symbol)\r\n            return new ACYSwapErrorStatus(\"please choose tokens\");\r\n        if (exactIn && inToken0Amount == \"0\")\r\n            return new ACYSwapErrorStatus(\"token0Amount is 0\");\r\n        if (!exactIn && inToken1Amount == \"0\")\r\n            return new ACYSwapErrorStatus(\"token1Amount is 0\");\r\n        if(exactIn && inToken0Amount == \"\")\r\n            return new ACYSwapErrorStatus(\"token0Amount is \\\"\\\"\");\r\n        if(!exactIn && inToken1Amount==\"\")\r\n            return new ACYSwapErrorStatus(\"token1Amount is \\\"\\\"\");\r\n        if (exactIn && (isNaN(parseFloat(inToken0Amount))))\r\n            return new ACYSwapErrorStatus(\"token0Amount is NaN\");\r\n        if (!exactIn && (isNaN(parseFloat(inToken1Amount))))\r\n            return new ACYSwapErrorStatus(\"token1Amount is NaN\");\r\n\r\n        console.log(`token0Amount: ${inToken0Amount}`);\r\n        console.log(`token1Amount: ${inToken1Amount}`);\r\n\r\n        let token0IsETH = inToken0Symbol === \"ETH\";\r\n        let token1IsETH = inToken1Symbol === \"ETH\";\r\n\r\n        console.log(inputToken0);\r\n        console.log(inputToken1);\r\n\r\n        if (token0IsETH && token1IsETH) {\r\n            setSwapButtonState(false);\r\n            setSwapButtonContent(\"don't support ETH to ETH\");\r\n            return new ACYSwapErrorStatus(\"don't support ETH to ETH\");\r\n        }\r\n            // if one is ETH and other WETH, use WETH contract's deposit and withdraw\r\n        // wrap ETH into WETH\r\n        else if (token0IsETH && inToken1Symbol === \"WETH\") {\r\n            // UI should sync value of ETH and WETH\r\n            if (exactIn) {\r\n                setToken1Amount(inToken0Amount);\r\n                inToken1Amount=inToken0Amount;\r\n            }\r\n            else {\r\n                setToken0Amount(inToken1Amount);\r\n                inToken0Amount=inToken1Amount;\r\n            }\r\n            console.log(\"------------------ CHECK BALANCE ------------------\");\r\n            // Big Number comparison\r\n\r\n            let userToken0Balance = await getUserTokenBalanceRaw(\r\n                token0IsETH\r\n                    ? ETHER\r\n                    : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol),\r\n                account,\r\n                library\r\n            );\r\n\r\n            let userHasSufficientBalance;\r\n            try {\r\n                userHasSufficientBalance = userToken0Balance.gte(\r\n                    parseUnits(inToken0Amount, inToken0Decimal)\r\n                );\r\n            }catch(e){\r\n                console.log(\"this is wrong!\");\r\n                console.log(e);\r\n                setSwapButtonState(false);\r\n                if(e.fault===\"underflow\") setSwapButtonContent(e.fault);\r\n                else setSwapButtonContent(\"unknow error\");\r\n                return new ACYSwapErrorStatus(e.fault);\r\n            };\r\n\r\n\r\n\r\n            console.log(userToken0Balance);\r\n            console.log(\"token0Amount\");\r\n            console.log(inToken0Amount);\r\n\r\n            // quit if user doesn't have enough balance, otherwise this will cause error\r\n            if (!userHasSufficientBalance) {\r\n                setSwapButtonState(false);\r\n                setSwapButtonContent(\"NOT enough balance\");\r\n                return new ACYSwapErrorStatus(\"NOT enough balance\");\r\n            }\r\n            // setEstimatedStatus(\"change ETH to WETH\");\r\n            setSwapButtonState(true);\r\n            setSwapButtonContent(\"wrap\");\r\n\r\n            const wethContract = getContract(inToken1Address, WETHABI, library, account);\r\n            let wrappedAmount;\r\n\r\n            try{\r\n                wrappedAmount = BigNumber.from(\r\n                    parseUnits(inToken0Amount, inToken0Decimal)\r\n                ).toHexString();\r\n            }catch(e){\r\n                console.log(\"wrappedAmount!!\");\r\n                console.log(e);\r\n                setSwapButtonState(false);\r\n                if(e.fault===\"underflow\") {\r\n                    setSwapButtonContent(e.fault);\r\n                    return new ACYSwapErrorStatus(e.fault);\r\n                }else{\r\n                    setSwapButtonContent(\"unknow error\");\r\n                    return new ACYSwapErrorStatus(\"unknow error\");\r\n                }\r\n\r\n            };\r\n\r\n\r\n            setWethContract(wethContract);\r\n            setWrappedAmount(wrappedAmount);\r\n\r\n            // let result = await wethContract\r\n            //     .deposit({\r\n            //         value: wrappedAmount,\r\n            //     })\r\n            //     .catch((e) => {\r\n            //         console.log(e);\r\n            //         return new ACYSwapErrorStatus(\"WETH Deposit failed\");\r\n            //     });\r\n            // return result;\r\n            return \"Wrap is ok\";\r\n        }\r\n        else if (inToken0Symbol === \"WETH\" && token1IsETH) {\r\n            console.log(\"UNWRAP\");\r\n            if (exactIn) {\r\n                setToken1Amount(inToken0Amount);\r\n                inToken1Amount=inToken0Amount;\r\n            }\r\n            else {\r\n                setToken0Amount(inToken1Amount);\r\n                inToken0Amount=inToken1Amount;\r\n            }\r\n\r\n            let userToken0Balance = await getUserTokenBalanceRaw(\r\n                token0IsETH\r\n                    ? ETHER\r\n                    : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol),\r\n                account,\r\n                library\r\n            );\r\n\r\n            let userHasSufficientBalance;\r\n            try{\r\n                userHasSufficientBalance = userToken0Balance.gte(\r\n                    parseUnits(inToken0Amount, inToken0Decimal)\r\n                );\r\n            }catch(e){\r\n                console.log(\"userHasSufficientBalance!!!\");\r\n                console.log(e);\r\n                setSwapButtonState(false);\r\n                if(e.fault===\"underflow\"){\r\n                    setSwapButtonContent(e.fault);\r\n                    return new ACYSwapErrorStatus(e.fault);\r\n                }else{\r\n                    setSwapButtonContent(\"unknow error\");\r\n                    return new ACYSwapErrorStatus(\"unknow error\");\r\n                }\r\n            };\r\n\r\n            // quit if user doesn't have enough balance, otherwise this will cause error\r\n            if (!userHasSufficientBalance) {\r\n                setSwapButtonState(false);\r\n                setSwapButtonContent(\"Not enough balance\");\r\n                return new ACYSwapErrorStatus(\"NOT enough balance\");\r\n            }\r\n\r\n            setSwapButtonState(true);\r\n            setSwapButtonContent(\"unwrap\");\r\n\r\n            const wethContract = getContract(inToken0Address, WETHABI, library, account);\r\n\r\n            let wrappedAmount;\r\n            try{\r\n                wrappedAmount = BigNumber.from(\r\n                    parseUnits(inToken0Amount, inToken0Decimal)\r\n                ).toHexString();\r\n            }catch(e){\r\n                console.log(\"wrappedAmount!!!\");\r\n                console.log(e);\r\n                setSwapButtonState(false);\r\n                if(e.fault===\"underflow\") {\r\n                    setSwapButtonContent(e.fault);\r\n                    return new ACYSwapErrorStatus(e.fault);\r\n                }else{\r\n                    setSwapButtonContent(\"unknow error\");\r\n                    return new ACYSwapErrorStatus(\"unknow error\");\r\n                }\r\n            }\r\n            setWethContract(wethContract);\r\n            setWrappedAmount(wrappedAmount);\r\n\r\n            // let result = await wethContract.withdraw(wrappedAmount).catch((e) => {\r\n            //     console.log(e);\r\n            //     return new ACYSwapErrorStatus(\"WETH Withdrawal failed\");\r\n            // });\r\n            // return result;\r\n\r\n            return \"unwrap is ok\";\r\n        }\r\n        // ETH <-> Non-WETH ERC20     OR     Non-WETH ERC20 <-> Non-WETH ERC20\r\n        else {\r\n            console.log(\"SWAP\");\r\n            console.log(\"------------------ CONSTRUCT TOKEN ------------------\");\r\n            // use WETH for ETHER to work with Uniswap V2 SDK\r\n            const token0 = token0IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol);\r\n            const token1 = token1IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken1Address, inToken1Decimal, inToken1Symbol);\r\n\r\n            if (token0.equals(token1)) {\r\n                setSwapButtonState(false);\r\n                setSwapButtonContent(\"tokens are same\");\r\n                return new ACYSwapErrorStatus(\"tokens are same\");\r\n            }\r\n            // get pair using our own provider\r\n            const pair = await Fetcher.fetchPairData(token0, token1, library).catch(\r\n                (e) => {\r\n                    return new ACYSwapErrorStatus(\r\n                        `${token0.symbol} - ${token1.symbol} pool does not exist. Create one?`\r\n                    );\r\n                }\r\n            );\r\n            if (pair instanceof ACYSwapErrorStatus) {\r\n                setSwapButtonState(false);\r\n                setSwapButtonContent(\"pool doesn't exist\");\r\n                return pair;\r\n            }\r\n\r\n            console.log(pair);\r\n            setPair(pair);\r\n            console.log(\"------------------ CONSTRUCT ROUTE ------------------\");\r\n            // This is where we let Uniswap SDK know we are not using WETH but ETHER\r\n\r\n            const route = new Route(\r\n                [pair],\r\n                token0IsETH ? ETHER : token0,\r\n                token1IsETH ? ETHER : token1\r\n            );\r\n\r\n            console.log(route);\r\n\r\n            setRoute(route);\r\n            console.log(\"------------------ PARSE AMOUNT ------------------\");\r\n\r\n            // convert typed in amount to BigNumbe rusing ethers.js's parseUnits then to string,\r\n            console.log(inToken0Amount);\r\n            console.log(inToken0Decimal);\r\n\r\n            let parsedAmount;\r\n\r\n            try{\r\n                parsedAmount = exactIn\r\n                    ? new TokenAmount(\r\n                        token0,\r\n                        parseUnits(inToken0Amount, inToken0Decimal)\r\n                    ).raw.toString(16)\r\n                    : new TokenAmount(\r\n                        token1,\r\n                        parseUnits(inToken1Amount, inToken1Decimal)\r\n                    ).raw.toString(16);\r\n            }catch(e){\r\n                console.log(\"parsedAmount!!!\");\r\n                console.log(e);\r\n                setSwapButtonState(false);\r\n                if(e.fault===\"underflow\") {\r\n                    setSwapButtonContent(e.fault);\r\n                    return new ACYSwapErrorStatus(e.fault);\r\n                }else{\r\n                    setSwapButtonContent(\"unknow error\");\r\n                    return new ACYSwapErrorStatus(\"unknow error\");\r\n                }\r\n            }\r\n\r\n            let inputAmount;\r\n            // CurrencyAmount instance is required for Trade contructor if input is ETHER\r\n            if ((token0IsETH && exactIn) || (token1IsETH && !exactIn)) {\r\n                inputAmount = new CurrencyAmount(ETHER, `0x${parsedAmount}`);\r\n            } else {\r\n                inputAmount = new TokenAmount(\r\n                    exactIn ? token0 : token1,\r\n                    `0x${parsedAmount}`\r\n                );\r\n            }\r\n            console.log(\"estimated dependent amount\");\r\n            // console.log(pair.priceOf(token0).quote(inputAmount).raw.toString());\r\n            let dependentTokenAmount = pair\r\n                .priceOf(token0)\r\n                .quote(new TokenAmount(token0, inputAmount.raw));\r\n\r\n            let parsed =\r\n                token1 === ETHER\r\n                    ? CurrencyAmount.ether(dependentTokenAmount.raw)\r\n                    : dependentTokenAmount;\r\n            console.log(parsed.toExact());\r\n\r\n//===================================================================================\r\n\r\n            console.log(\"------------------ CONSTRUCT TRADE ------------------\");\r\n            let trade;\r\n            try {\r\n                trade = new Trade(\r\n                    route,\r\n                    inputAmount,\r\n                    exactIn ? TradeType.EXACT_INPUT : TradeType.EXACT_OUTPUT\r\n                );\r\n            } catch (e) {\r\n                if (e instanceof InsufficientReservesError) {\r\n                    setSwapButtonState(false);\r\n                    setSwapButtonContent(\"Insufficient liquidity for this trade\");\r\n                    console.log(\"Insufficient reserve!\");\r\n                    return new ACYSwapErrorStatus(\"Insufficient reserve!\");\r\n                } else {\r\n                    setSwapButtonState(false);\r\n                    setSwapButtonContent(\"Unhandled exception!\");\r\n                    console.log(\"Unhandled exception!\");\r\n                    console.log(e);\r\n                    return new ACYSwapErrorStatus(\"Unhandled exception!\");\r\n                }\r\n            }\r\n\r\n            console.log(trade);\r\n            setTrade(trade);\r\n            console.log(\"------------------ SLIPPAGE CALCULATE ------------------\");\r\n\r\n            let slippageAdjustedAmount;\r\n            let minAmountOut;\r\n            let maxAmountIn;\r\n\r\n            // calculate slippage adjusted amount\r\n            if (exactIn) {\r\n                // console.log(trade.outputAmount.toExact());\r\n                // setToken1Amount(trade.outputAmount.toExact());\r\n                console.log(\r\n                    `By algorithm, expected to get: ${trade.outputAmount.toExact()}`\r\n                );\r\n                // if provided exact token in, we want to know min out token amount\r\n                minAmountOut = trade.minimumAmountOut(allowedSlippage);\r\n                slippageAdjustedAmount = minAmountOut.raw.toString();\r\n\r\n                // update UI with estimated output token amount\r\n                setToken1Amount(trade.outputAmount.toExact());\r\n                console.log(`Minimum received: ${slippageAdjustedAmount}`);\r\n\r\n            } else {\r\n                console.log(\r\n                    `By algorithm, expected to get: ${trade.inputAmount.toExact()}`\r\n                );\r\n                maxAmountIn = trade.maximumAmountIn(allowedSlippage);\r\n                slippageAdjustedAmount = maxAmountIn.raw.toString();\r\n                setToken0Amount(trade.inputAmount.toExact());\r\n                console.log(`Maximum pay: ${slippageAdjustedAmount}`);\r\n            }\r\n\r\n\r\n            setSlippageAdjustedAmount(slippageAdjustedAmount);\r\n            setMinAmountOut(minAmountOut);\r\n            setMaxAmountIn(maxAmountIn);\r\n\r\n            let userToken0Balance = await getUserTokenBalanceRaw(\r\n                token0IsETH\r\n                    ? ETHER\r\n                    : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol),\r\n                account,\r\n                library\r\n            );\r\n\r\n\r\n            let userHasSufficientBalance;\r\n            try{\r\n                userHasSufficientBalance = userToken0Balance.gte(\r\n                    parseUnits(inToken0Amount, inToken0Decimal)\r\n                );\r\n            }catch(e){\r\n                console.log(\"wrappedAmount!!!\");\r\n                console.log(e);\r\n                setSwapButtonState(false);\r\n                setSwapButtonContent(e.fault);\r\n                return new ACYSwapErrorStatus(e.fault);\r\n            }\r\n\r\n\r\n            // quit if user doesn't have enough balance, otherwise this will cause error\r\n            if (!userHasSufficientBalance) {\r\n                setSwapButtonState(false);\r\n                setSwapButtonContent(\"Not Enough balance\");\r\n                return;\r\n            }\r\n\r\n            console.log(\"------------------ BREAKDOWN ------------------\");\r\n            let {priceImpactWithoutFee, realizedLPFee} =\r\n                computeTradePriceBreakdown(trade);\r\n            let breakdownInfo = [\r\n                // `Slice Slippage tolerance:` ${allowedSlippage} %`\r\n                `Slippage tolerance : ${slippage}%`,\r\n                `Price impact : ${priceImpactWithoutFee.toFixed(2)}%`,\r\n                `LP FEE : ${realizedLPFee?.toSignificant(6)} ${\r\n                    trade.inputAmount.currency.symbol\r\n                }`,\r\n                `${exactIn ? \"Min received:\" : \"Max sold\"} : ${\r\n                    exactIn ? minAmountOut.toSignificant(4) : maxAmountIn.toSignificant(4)\r\n                } ${\r\n                    exactIn\r\n                        ? trade.outputAmount.currency.symbol\r\n                        : trade.inputAmount.currency.symbol\r\n                }`,\r\n            ];\r\n\r\n            // setEstimatedStatus(\"you can click the swap button\");\r\n            setSwapBreakdown(breakdownInfo);\r\n\r\n            console.log(\"------------------ ALLOWANCE ------------------\");\r\n            if (!token0IsETH) {\r\n                let allowance = await getAllowance(\r\n                    inToken0Address,\r\n                    account,\r\n                    ROUTER_ADDRESS,\r\n                    library,\r\n                    account\r\n                );\r\n\r\n                console.log(\r\n                    `Current allowance for ${trade.inputAmount.currency.symbol}:`\r\n                );\r\n                console.log(allowance);\r\n                let token0AmountToApprove = exactIn\r\n                    ? inputAmount.raw.toString()\r\n                    : slippageAdjustedAmount;\r\n                let token0approval = await checkTokenIsApproved(\r\n                    inToken0Address,\r\n                    token0AmountToApprove,\r\n                    library,\r\n                    account\r\n                );\r\n                console.log(token0approval);\r\n                if (!token0approval) {\r\n                    console.log(\"Not enough allowance\");\r\n                    setApproveAmount(token0AmountToApprove);\r\n                    // when needApprove = true, please show the button of [Approve]\r\n                    setNeedApprove(true);\r\n                    setApproveButtonStatus(true);\r\n                    setSwapButtonState(false);\r\n                    setSwapButtonContent(\"need approve\");\r\n                    return \"approve is ok\";\r\n                }else {\r\n                    setSwapButtonContent(\"swap\");\r\n                    setSwapButtonState(true);\r\n                    return \"swap is ok\";\r\n                }\r\n            }\r\n            setSwapButtonContent(\"swap\");\r\n            setSwapButtonState(true);\r\n\r\n\r\n            return \"swap is ok\";\r\n        }\r\n    })();\r\n    if (status instanceof ACYSwapErrorStatus) {\r\n        console.log(status.getErrorText());\r\n    } else {\r\n        console.log(status);\r\n    }\r\n    return;\r\n}\r\n\r\nexport async function swap(\r\n    inputToken0,\r\n    inputToken1,\r\n    allowedSlippage = INITIAL_ALLOWED_SLIPPAGE,\r\n    exactIn = true,\r\n    chainId,\r\n    library,\r\n    account,\r\n    pair,\r\n    route,\r\n    trade,\r\n    slippageAdjustedAmount,\r\n    minAmountOut,\r\n    maxAmountIn,\r\n    wethContract,\r\n    wrappedAmount,\r\n    setSwapStatus\r\n) {\r\n    let status = await (async () => {\r\n        // check uniswap\r\n        console.log(FACTORY_ADDRESS);\r\n        // change slippage from bips (0.01%) into percentage\r\n        allowedSlippage = new Percent(allowedSlippage, 10000);\r\n\r\n        let contract = getRouterContract(library, account);\r\n        let {\r\n            address: inToken0Address,\r\n            symbol: inToken0Symbol,\r\n            decimal: inToken0Decimal,\r\n            amount: inToken0Amount,\r\n        } = inputToken0;\r\n        let {\r\n            address: inToken1Address,\r\n            symbol: inToken1Symbol,\r\n            decimal: inToken1Decimal,\r\n            amount: inToken1Amount,\r\n        } = inputToken1;\r\n\r\n        console.log(`token0Amount: ${inToken0Amount}`);\r\n        console.log(`token1Amount: ${inToken1Amount}`);\r\n\r\n        let token0IsETH = inToken0Symbol === \"ETH\";\r\n        let token1IsETH = inToken1Symbol === \"ETH\";\r\n\r\n        console.log(inputToken0);\r\n        console.log(inputToken1);\r\n\r\n        if (token0IsETH && token1IsETH)\r\n            return new ACYSwapErrorStatus(\"Doesn't support ETH to ETH\");\r\n        console.log(\"------------------ WRAP OR SWAP  ------------------\");\r\n        // if one is ETH and other WETH, use WETH contract's deposit and withdraw\r\n        // wrap ETH into WETH\r\n        if (token0IsETH && inToken1Symbol === \"WETH\") {\r\n            console.log(\"WRAP\");\r\n            // UI should sync value of ETH and WETH\r\n            // if (exactIn) setToken1Amount(token0Amount);\r\n            // else setToken0Amount(token1Amount);\r\n            let result = await wethContract\r\n                .deposit({\r\n                    value: wrappedAmount,\r\n                })\r\n                .catch((e) => {\r\n                    console.log(e);\r\n                    return new ACYSwapErrorStatus(\"WETH Deposit failed\");\r\n                });\r\n\r\n            return result;\r\n        }\r\n        // unwrap WETH into ETH\r\n        else if (inToken0Symbol === \"WETH\" && token1IsETH) {\r\n            console.log(\"UNWRAP\");\r\n\r\n            // UI should sync value of ETH and WETH\r\n            // if (exactIn) setToken1Amount(token0Amount);\r\n            // else setToken0Amount(token1Amount);\r\n\r\n            let result = await wethContract.withdraw(wrappedAmount).catch((e) => {\r\n                console.log(e);\r\n                return new ACYSwapErrorStatus(\"WETH Withdrawal failed\");\r\n            });\r\n            return result;\r\n        }\r\n        // ETH <-> Non-WETH ERC20     OR     Non-WETH ERC20 <-> Non-WETH ERC20\r\n        else {\r\n            console.log(\"SWAP\");\r\n\r\n            console.log(\"------------------ CONSTRUCT TOKEN ------------------\");\r\n            // use WETH for ETHER to work with Uniswap V2 SDK\r\n            const token0 = token0IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol);\r\n            const token1 = token1IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken1Address, inToken1Decimal, inToken1Symbol);\r\n            console.log(token0);\r\n            console.log(token1);\r\n            // quit if the two tokens are equivalent, i.e. have the same chainId and address\r\n            if (token0.equals(token1)) return new ACYSwapErrorStatus(\"Equal tokens!\");\r\n            // helper function from uniswap sdk to get pair address, probably needed if want to replace fetchPairData\r\n            // get pair using our own provider\r\n            console.log(\"------------------ CONSTRUCT PAIR ------------------\");\r\n            console.log(\"FETCH\");\r\n            console.log(pair);\r\n            console.log(\"------------------ CONSTRUCT ROUTE ------------------\");\r\n            // This is where we let Uniswap SDK know we are not using WETH but ETHER\r\n            console.log(route);\r\n            console.log(\"------------------ PARSE AMOUNT ------------------\");\r\n\r\n            console.log(\"------------------ CONSTRUCT TRADE ------------------\");\r\n            console.log(trade);\r\n            console.log(\"------------------ SLIPPAGE CALCULATE ------------------\");\r\n            console.log(slippageAdjustedAmount);\r\n            console.log(minAmountOut);\r\n            console.log(maxAmountIn);\r\n            console.log(\"------------------ ALLOWANCE ------------------\");\r\n            console.log(\"say something about allowance\");\r\n            console.log(\"------------------ PREPARE SWAP ------------------\");\r\n\r\n\r\n            let {methodName, args, value} = Router.swapCallParameters(trade, {\r\n                feeOnTransfer: false,\r\n                allowedSlippage,\r\n                recipient: account,\r\n                ttl: 60,\r\n            });\r\n            const options = !value || isZero(value) ? {} : {value};\r\n\r\n            console.log(\"------------------ ARGUMENTS ------------------\");\r\n            console.log(options);\r\n            console.log(args);\r\n\r\n            let result = await contract.estimateGas[methodName](...args, options)\r\n                .then((gasEstimate) => {\r\n                    return contract[methodName](...args, {\r\n                        gasLimit: calculateGasMargin(gasEstimate),\r\n                        ...options,\r\n                    });\r\n                })\r\n                .catch((e) => {\r\n                    return new ACYSwapErrorStatus(`${methodName} failed with error ${e}`);\r\n                });\r\n            return result;\r\n        }\r\n    })();\r\n    if (status instanceof ACYSwapErrorStatus) {\r\n        setSwapStatus(status.getErrorText());\r\n    } else {\r\n        console.log(status);\r\n        let url = \"https://rinkeby.etherscan.io/tx/\" + status.hash;\r\n        setSwapStatus(<div><a href={url} target={\"_blank\"}>view it on etherscan</a></div>);\r\n    }\r\n}\r\n\r\nconst SwapComponent = () => {\r\n    let [token0, setToken0] = useState(null);\r\n    let [token1, setToken1] = useState(null);\r\n    let [token0Balance, setToken0Balance] = useState(\"not know yet\");\r\n    let [token1Balance, setToken1Balance] = useState(\"not know yet\");\r\n    let [token0BalanceShow, setToken0BalanceShow] = useState(false);\r\n    let [token1BalanceShow, setToken1BalanceShow] = useState(false);\r\n    let [token0Amount, setToken0Amount] = useState();\r\n    let [token1Amount, setToken1Amount] = useState();\r\n    let [slippageTolerance, setSlippageTolerance] = useState(INITIAL_ALLOWED_SLIPPAGE / 100);\r\n    //exactIn = true 在第一行输入\r\n    //exactIn = false 在第二行输入\r\n    let [exactIn, setExactIn] = useState(true);\r\n\r\n    let [needApprove, setNeedApprove] = useState(false);\r\n    let [approveAmount, setApproveAmount] = useState(\"0\");\r\n    let [approveButtonStatus,setApproveButtonStatus]=useState(true);\r\n\r\n    // Breakdown shows the estimated information for swap\r\n\r\n    // let [estimatedStatus,setEstimatedStatus]=useState();\r\n    let [swapBreakdown, setSwapBreakdown] = useState();\r\n    let [swapButtonState, setSwapButtonState] = useState(true);\r\n    let [swapButtonContent, setSwapButtonContent] = useState(\"Connect to Wallet\");\r\n    let [swapStatus, setSwapStatus] = useState();\r\n\r\n\r\n    let[pair,setPair]=useState();\r\n    let[route,setRoute]=useState();\r\n    let[trade,setTrade]=useState();\r\n    let[slippageAdjustedAmount,setSlippageAdjustedAmount]=useState();\r\n    let[minAmountOut,setMinAmountOut]=useState();\r\n    let[maxAmountIn,setMaxAmountIn]=useState();\r\n    let[wethContract,setWethContract]=useState();\r\n    let[wrappedAmount,setWrappedAmount]=useState();\r\n\r\n\r\n    const individualFieldPlaceholder = \"Enter amount\";\r\n    const dependentFieldPlaceholder = \"Estimated value\";\r\n    const slippageTolerancePlaceholder = \"please input a number from 1.00 to 100.00\";\r\n\r\n    const {account, chainId, library, activate} = useWeb3React();\r\n\r\n\r\n    const injected = new InjectedConnector({\r\n        supportedChainIds: [1, 3, 4, 5, 42, 80001],\r\n    });\r\n\r\n    // This is to connect wallet.\r\n    useEffect(() => {\r\n        // activate(injected);\r\n    }, []);\r\n\r\n    // token1Amount is changed according to token0Amount\r\n    let t0Changed = useCallback(async () => {\r\n        if (!token0 || !token1) return;\r\n        if (!exactIn) return;\r\n        await swapGetEstimated(\r\n            {\r\n                ...token0,\r\n                amount: token0Amount,\r\n            },\r\n            {\r\n                ...token1,\r\n                amount: token1Amount,\r\n            },\r\n            slippageTolerance * 100,\r\n            exactIn,\r\n            chainId,\r\n            library,\r\n            account,\r\n            setToken0Amount,\r\n            setToken1Amount,\r\n            setNeedApprove,\r\n            setApproveAmount,\r\n            setApproveButtonStatus,\r\n            setSwapBreakdown,\r\n            setSwapButtonState,\r\n            setSwapButtonContent,\r\n            setSwapStatus,\r\n            setPair,\r\n            setRoute,\r\n            setTrade,\r\n            setSlippageAdjustedAmount,\r\n            setMinAmountOut,\r\n            setMaxAmountIn,\r\n            setWethContract,\r\n            setWrappedAmount\r\n        );\r\n    }, [token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account]);\r\n    // token0Amount is changed according to token1Amount\r\n    let t1Changed = useCallback(async () => {\r\n        if (!token0 || !token1) return;\r\n        if (exactIn) return;\r\n        await swapGetEstimated(\r\n            {\r\n                ...token0,\r\n                amount: token0Amount,\r\n            },\r\n            {\r\n                ...token1,\r\n                amount: token1Amount,\r\n            },\r\n            slippageTolerance * 100,\r\n            exactIn,\r\n            chainId,\r\n            library,\r\n            account,\r\n            setToken0Amount,\r\n            setToken1Amount,\r\n            setNeedApprove,\r\n            setApproveAmount,\r\n            setApproveButtonStatus,\r\n            setSwapBreakdown,\r\n            setSwapButtonState,\r\n            setSwapButtonContent,\r\n            setSwapStatus,\r\n            setPair,\r\n            setRoute,\r\n            setTrade,\r\n            setSlippageAdjustedAmount,\r\n            setMinAmountOut,\r\n            setMaxAmountIn,\r\n            setWethContract,\r\n            setWrappedAmount\r\n        );\r\n    }, [token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account]);\r\n    useEffect(() => {\r\n        t0Changed();\r\n    }, [token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account]);\r\n    useEffect(() => {\r\n        t1Changed();\r\n    }, [token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account]);\r\n\r\n    useEffect(() => {\r\n        if (account == undefined) {\r\n            setSwapButtonState(true);\r\n            setSwapButtonContent(\"Connect to Wallet\");\r\n        } else {\r\n            setSwapButtonState(false);\r\n            setSwapButtonContent(\"choose tokens and amount\");\r\n        }\r\n    }, [account]);\r\n    return (\r\n        <div>\r\n            <h1>swap</h1>\r\n            <Alert variant=\"success\">\r\n                <Alert.Heading>Hey, nice to see you</Alert.Heading>\r\n                <p>{account}</p>\r\n            </Alert>\r\n            <Form>\r\n                <Form.Group className=\"mb-3\" controlId=\"formBasicEmail\">\r\n                    <Dropdown>\r\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\r\n                            {(token0 && token0.symbol) || \"In token\"}\r\n                        </Dropdown.Toggle>\r\n                        <Dropdown.Menu>\r\n                            {supportedTokens.map((token, index) => (\r\n                                <Dropdown.Item\r\n                                    key={index}\r\n                                    onClick={async () => {\r\n                                        if (account == undefined) {\r\n                                            alert(\"please connect to your account\");\r\n                                        } else {\r\n                                            setToken0(token);\r\n                                            setToken0Balance(\r\n                                                await getUserTokenBalance(\r\n                                                    token,\r\n                                                    chainId,\r\n                                                    account,\r\n                                                    library\r\n                                                )\r\n                                            );\r\n                                            setToken0BalanceShow(true);\r\n                                        }\r\n                                    }\r\n                                    }\r\n                                >\r\n                                    {token.symbol}\r\n                                </Dropdown.Item>\r\n                            ))}\r\n                        </Dropdown.Menu>\r\n                    </Dropdown>\r\n                    <Form.Control\r\n                        value={token0Amount}\r\n                        placeholder={\r\n                            exactIn ? individualFieldPlaceholder : dependentFieldPlaceholder\r\n                        }\r\n                        onFocus={(e) => {\r\n                            setExactIn(true);\r\n                        }\r\n                        }\r\n                        onChange={(e) => {\r\n                            setToken0Amount(e.target.value);\r\n                        }}\r\n                    />\r\n                    {token0BalanceShow ? <small>Balance: {token0Balance}</small> : <small>not know yet</small>}\r\n                </Form.Group>\r\n                <Form.Group className=\"mb-3\" controlId=\"formBasicPassword\">\r\n                    <Dropdown>\r\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\r\n                            {(token1 && token1.symbol) || \"Out token\"}\r\n                        </Dropdown.Toggle>\r\n                        <Dropdown.Menu>\r\n                            {supportedTokens.map((token, index) => (\r\n                                <Dropdown.Item\r\n                                    key={index}\r\n                                    onClick={async () => {\r\n                                        if (account == undefined) {\r\n                                            alert(\"please connect to your account\");\r\n                                        } else {\r\n                                            setToken1(token);\r\n                                            setToken1Balance(\r\n                                                await getUserTokenBalance(\r\n                                                    token,\r\n                                                    chainId,\r\n                                                    account,\r\n                                                    library\r\n                                                )\r\n                                            );\r\n                                            setToken1BalanceShow(true);\r\n                                        }\r\n                                    }}\r\n                                >\r\n                                    {token.symbol}\r\n                                </Dropdown.Item>\r\n                            ))}\r\n                        </Dropdown.Menu>\r\n                    </Dropdown>\r\n                    <Form.Control\r\n                        value={token1Amount}\r\n                        placeholder={\r\n                            exactIn ? dependentFieldPlaceholder : individualFieldPlaceholder\r\n                        }\r\n                        onFocus={(e) => {\r\n                            setExactIn(false);\r\n                        }}\r\n                        onChange={(e) => {\r\n                            setToken1Amount(e.target.value);\r\n                        }}\r\n                    />\r\n                    {token1BalanceShow ? <small>Balance: {token1Balance}</small> : <small>not know yet</small>}\r\n                </Form.Group>\r\n\r\n\r\n                <InputGroup size=\"sm\" className=\"mb-3\">\r\n                    <InputGroup.Text id=\"inputGroup-sizing-sm\">Slippage tolerance </InputGroup.Text>\r\n                    <FormControl\r\n                        aria-label=\"Small\"\r\n                        aria-describedby=\"inputGroup-sizing-sm\"\r\n                        placeholder={slippageTolerancePlaceholder}\r\n                        onChange={(e => {\r\n                            setSlippageTolerance(e.target.value);\r\n                        })}\r\n\r\n                    />\r\n                    <InputGroup.Text>%</InputGroup.Text>\r\n                </InputGroup>\r\n\r\n                <Alert variant=\"danger\">\r\n                    the Slippage Tolerance you choose is [ {slippageTolerance}% ]\r\n                </Alert>\r\n\r\n                <Alert variant=\"info\">\r\n                    {swapBreakdown && <mark> Swap breakdown:</mark>}\r\n                    {swapBreakdown && swapBreakdown.map((info) => <p>{info}</p>)}\r\n                </Alert>\r\n                {\r\n                    needApprove == true && <mark>\r\n                        <Button\r\n                            variant=\"warning\"\r\n                            onClick={async () => {\r\n                                let state = await approve(token0.address, approveAmount, library, account);\r\n                                if (state == true) {\r\n                                    setSwapButtonState(true);\r\n                                    setSwapButtonContent(\"SWAP\");\r\n                                    setApproveButtonStatus(false);\r\n                                }\r\n                            }}\r\n                            disabled={!approveButtonStatus}\r\n                        >\r\n                            Approve\r\n                        </Button>\r\n                        {' '}\r\n\r\n                    </mark>\r\n                }\r\n\r\n\r\n                <Button\r\n                    variant=\"success\"\r\n                    disabled={!swapButtonState}\r\n\r\n                    onClick={() => {\r\n                        if (account == undefined) {\r\n                            activate(injected);\r\n                        } else {\r\n\r\n\r\n                            swap(\r\n                                {\r\n                                    ...token0,\r\n                                    amount: token0Amount,\r\n                                },\r\n                                {\r\n                                    ...token1,\r\n                                    amount: token1Amount,\r\n                                },\r\n                                slippageTolerance * 100,\r\n                                exactIn,\r\n                                chainId,\r\n                                library,\r\n                                account,\r\n                                pair,\r\n                                route,\r\n                                trade,\r\n                                slippageAdjustedAmount,\r\n                                minAmountOut,\r\n                                maxAmountIn,\r\n                                wethContract,\r\n                                wrappedAmount,\r\n                                setSwapStatus\r\n                            );\r\n                        }\r\n                    }\r\n                    }\r\n                >\r\n                    {swapButtonContent}\r\n                </Button>\r\n                <Alert variant=\"primary\">\r\n                    { swapStatus && <mark> swapStatus:</mark>}\r\n                    { swapStatus && <p> {swapStatus}</p>}\r\n                </Alert>\r\n            </Form>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default SwapComponent;\r\n","D:\\GitHub\\acy-dex-swap\\src\\components\\LiquidityComponent.js",["73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94"],"import {useWeb3React} from \"@web3-react/core\";\r\nimport {InjectedConnector} from \"@web3-react/injected-connector\";\r\nimport {useCallback, useEffect, useState} from \"react\";\r\nimport {\r\n    ACYSwapErrorStatus,\r\n    approve,\r\n    calculateGasMargin,\r\n    calculateSlippageAmount,\r\n    checkTokenIsApproved,\r\n    getRouterContract,\r\n    getTokenTotalSupply,\r\n    getUserTokenBalance,\r\n    getUserTokenBalanceRaw,\r\n    INITIAL_ALLOWED_SLIPPAGE,\r\n    supportedTokens,\r\n} from \"../utils\";\r\n\r\nimport {Alert, Button, Dropdown, Form, FormControl, InputGroup} from \"react-bootstrap\";\r\nimport {\r\n    CurrencyAmount,\r\n    ETHER,\r\n    FACTORY_ADDRESS,\r\n    Fetcher,\r\n    InsufficientReservesError,\r\n    Percent,\r\n    Token,\r\n    TokenAmount,\r\n    WETH,\r\n} from \"@uniswap/sdk\";\r\nimport {BigNumber} from \"@ethersproject/bignumber\";\r\nimport {parseUnits} from \"@ethersproject/units\";\r\n\r\n\r\n// get the estimated amount of the other token required when adding liquidity, in readable string.\r\nexport async function getEstimated(\r\n    inputToken0,\r\n    inputToken1,\r\n    allowedSlippage = INITIAL_ALLOWED_SLIPPAGE,\r\n    exactIn = true,\r\n    chainId,\r\n    library,\r\n    account,\r\n    setToken0Amount,\r\n    setToken1Amount,\r\n    setNeedApproveToken0,\r\n    setNeedApproveToken1,\r\n    setApproveAmountToken0,\r\n    setApproveAmountToken1,\r\n    setApproveToken0ButtonShow,\r\n    setApproveToken1ButtonShow,\r\n    setLiquidityBreakdown,\r\n    setButtonContent,\r\n    setButtonStatus,\r\n    setLiquidityStatus,\r\n    setPair,\r\n    setNoLiquidity,\r\n    setParsedToken0Amount,\r\n    setParsedToken1Amount,\r\n    setArgs,\r\n    setValue\r\n) {\r\n    let status = await (async () => {\r\n        setNeedApproveToken0(false);\r\n        setNeedApproveToken1(false);\r\n        setApproveAmountToken0(\"0\");\r\n        setApproveAmountToken1(\"0\");\r\n        setApproveToken0ButtonShow(false);\r\n        setApproveToken1ButtonShow(false);\r\n        setLiquidityBreakdown(\"\");\r\n        setButtonContent(\"loading...\");\r\n        setButtonStatus(false);\r\n        setLiquidityStatus(\"\");\r\n\r\n        console.log(FACTORY_ADDRESS);\r\n\r\n        let router = getRouterContract(library, account);\r\n        let slippage = allowedSlippage * 0.01;\r\n        let {\r\n            address: inToken0Address,\r\n            symbol: inToken0Symbol,\r\n            decimal: inToken0Decimal,\r\n            amount: inToken0Amount,\r\n        } = inputToken0;\r\n        let {\r\n            address: inToken1Address,\r\n            symbol: inToken1Symbol,\r\n            decimal: inToken1Decimal,\r\n            amount: inToken1Amount,\r\n        } = inputToken1;\r\n\r\n        if (!inputToken0.symbol || !inputToken1.symbol)\r\n            return new ACYSwapErrorStatus(\"please choose tokens\");\r\n        if (exactIn && inToken0Amount == \"0\")\r\n            return new ACYSwapErrorStatus(\"token0Amount is 0\");\r\n        if (!exactIn && inToken1Amount == \"0\")\r\n            return new ACYSwapErrorStatus(\"token1Amount is 0\");\r\n        if (exactIn && inToken0Amount == \"\")\r\n            return new ACYSwapErrorStatus(\"token0Amount is \\\"\\\"\");\r\n        if (!exactIn && inToken1Amount == \"\")\r\n            return new ACYSwapErrorStatus(\"token1Amount is \\\"\\\"\");\r\n        if (exactIn && (isNaN(parseFloat(inToken0Amount))))\r\n            return new ACYSwapErrorStatus(\"token0Amount is NaN\");\r\n        if (!exactIn && (isNaN(parseFloat(inToken1Amount))))\r\n            return new ACYSwapErrorStatus(\"token1Amount is NaN\");\r\n\r\n        let token0IsETH = inToken0Symbol === \"ETH\";\r\n        let token1IsETH = inToken1Symbol === \"ETH\";\r\n\r\n        console.log(inputToken0);\r\n        console.log(inputToken1);\r\n        if (token0IsETH && token1IsETH) {\r\n            setButtonContent(\"Doesn't support ETH to ETH\");\r\n            setButtonStatus(false);\r\n            return new ACYSwapErrorStatus(\"Doesn't support ETH to ETH\");\r\n        } else if (\r\n            (token0IsETH && inToken1Symbol === \"WETH\") ||\r\n            (inToken0Symbol === \"WETH\" && token1IsETH)\r\n        ) {\r\n            setButtonContent(\"Invalid pair WETH/ETH\");\r\n            setButtonStatus(false);\r\n            return new ACYSwapErrorStatus(\"Invalid pair WETH/ETH\");\r\n        }\r\n        // ETH <-> Non-WETH ERC20     OR     Non-WETH ERC20 <-> Non-WETH ERC20\r\n        else {\r\n            console.log(\"ADD LIQUIDITY\");\r\n            console.log(\"------------------ CONSTRUCT TOKEN ------------------\");\r\n\r\n            // use WETH for ETHER to work with Uniswap V2 SDK\r\n            const token0 = token0IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol);\r\n            const token1 = token1IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken1Address, inToken1Decimal, inToken1Symbol);\r\n\r\n            if (token0.equals(token1)) {\r\n                setButtonContent(\"Equal tokens\");\r\n                setButtonStatus(false);\r\n                return new ACYSwapErrorStatus(\"Equal tokens!\");\r\n            }\r\n            // get pair using our own provider\r\n            const pair = await Fetcher.fetchPairData(token0, token1, library)\r\n                .then((pair) => {\r\n                    console.log(pair.reserve0.raw.toString());\r\n                    console.log(pair.reserve1.raw.toString());\r\n                    return pair;\r\n                })\r\n                .catch((e) => {\r\n                    return new ACYSwapErrorStatus(\r\n                        `${token0.symbol} - ${token1.symbol} pool does not exist. Create one?`\r\n                    );\r\n                });\r\n\r\n            console.log(\"pair\");\r\n            console.log(pair);\r\n            setPair(pair);\r\n\r\n\r\n            let noLiquidity = false;\r\n            if (pair instanceof ACYSwapErrorStatus) {\r\n                noLiquidity = true;\r\n            }\r\n            setNoLiquidity(noLiquidity);\r\n            console.log(\"------------------ PARSE AMOUNT ------------------\");\r\n            // convert typed in amount to BigNumber using ethers.js's parseUnits,\r\n\r\n            let parsedAmount;\r\n            try {\r\n                parsedAmount = exactIn\r\n                    ? new TokenAmount(token0, parseUnits(inToken0Amount, inToken0Decimal))\r\n                    : new TokenAmount(token1, parseUnits(inToken1Amount, inToken1Decimal));\r\n\r\n            } catch (e) {\r\n                console.log(\"parsedAmount\");\r\n                console.log(e);\r\n                setButtonStatus(false);\r\n                if (e.fault === \"underflow\"){\r\n                    setButtonContent(e.fault);\r\n                    return new ACYSwapErrorStatus(e.fault);\r\n                }else {\r\n                    setButtonContent(\"unknow error\");\r\n                    return new ACYSwapErrorStatus(\"unknow error\");\r\n                }\r\n            }\r\n\r\n            let parsedToken0Amount;\r\n            let parsedToken1Amount;\r\n\r\n            // this is have pool\r\n            if (!noLiquidity) {\r\n                console.log(\"estimated dependent amount\");\r\n                let dependentTokenAmount;\r\n                if (exactIn) {\r\n                    dependentTokenAmount = pair.priceOf(token0).quote(parsedAmount);\r\n\r\n\r\n                    let token0TokenAmount;\r\n                    try {\r\n                        token0TokenAmount = new TokenAmount(\r\n                            token0,\r\n                            parseUnits(inToken0Amount, inToken0Decimal)\r\n                        );\r\n                    } catch (e) {\r\n                        console.log(\"token0TokenAmount\");\r\n                        console.log(e);\r\n                        setButtonStatus(false);\r\n                        if (e.fault === \"underflow\"){\r\n                            setButtonContent(e.fault);\r\n                            return new ACYSwapErrorStatus(e.fault);\r\n                        }else {\r\n                            setButtonContent(\"unknow error\");\r\n                            return new ACYSwapErrorStatus(\"unknow error\");\r\n                        }\r\n                    }\r\n\r\n                    parsedToken0Amount =\r\n                        token0 === ETHER\r\n                            ? CurrencyAmount.ether(token0TokenAmount.raw)\r\n                            : token0TokenAmount;\r\n\r\n                    parsedToken1Amount =\r\n                        token1 === ETHER\r\n                            ? CurrencyAmount.ether(dependentTokenAmount.raw)\r\n                            : dependentTokenAmount;\r\n                    setToken1Amount(dependentTokenAmount.toExact());\r\n                    inToken1Amount = dependentTokenAmount.toExact();\r\n                } else {\r\n                    dependentTokenAmount = pair.priceOf(token1).quote(parsedAmount);\r\n\r\n                    let token1TokenAmount;\r\n                    try{\r\n                        token1TokenAmount = new TokenAmount(\r\n                            token1,\r\n                            parseUnits(inToken1Amount, inToken1Decimal)\r\n                        );\r\n                    }catch(e){\r\n                        console.log(\"token0TokenAmount\");\r\n                        console.log(e);\r\n                        setButtonStatus(false);\r\n                        if (e.fault === \"underflow\"){\r\n                            setButtonContent(e.fault);\r\n                            return new ACYSwapErrorStatus(e.fault);\r\n                        }else {\r\n                            setButtonContent(\"unknow error\");\r\n                            return new ACYSwapErrorStatus(\"unknow error\");\r\n                        }\r\n                    }\r\n\r\n\r\n                    parsedToken0Amount =\r\n                        token0 === ETHER\r\n                            ? CurrencyAmount.ether(dependentTokenAmount.raw)\r\n                            : dependentTokenAmount;\r\n\r\n                    parsedToken1Amount =\r\n                        token1 === ETHER\r\n                            ? CurrencyAmount.ether(token1TokenAmount.raw)\r\n                            : token1TokenAmount;\r\n                    setToken0Amount(dependentTokenAmount.toExact());\r\n                    inToken0Amount = dependentTokenAmount.toExact();\r\n                }\r\n            } else {\r\n                // this is to create new pools\r\n                if (inToken0Amount === \"0\" || inToken1Amount === \"0\") {\r\n                    if (noLiquidity) {\r\n                        setButtonStatus(false);\r\n                        setButtonContent(\"create new pool\");\r\n\r\n                        return new ACYSwapErrorStatus(\r\n                            \"Creating a new pool, please enter both amounts\"\r\n                        );\r\n                    } else {\r\n                        setButtonStatus(false);\r\n                        setButtonContent(\"add liquidity\");\r\n                        return new ACYSwapErrorStatus(\r\n                            \"One field is empty, it's probably a new pool\"\r\n                        );\r\n                    }\r\n                }\r\n\r\n                try{\r\n                    parsedToken0Amount = new TokenAmount(\r\n                        token0,\r\n                        parseUnits(inToken0Amount, inToken0Decimal)\r\n                    );\r\n\r\n                    parsedToken1Amount = new TokenAmount(\r\n                        token1,\r\n                        parseUnits(inToken1Amount, inToken1Decimal)\r\n                    );\r\n                } catch(e) {\r\n                    console.log(\"parsedToken0Amount and parsedToken1Amount\");\r\n                    console.log(e);\r\n                    setButtonStatus(false);\r\n                    if (e.fault === \"underflow\") {\r\n                        setButtonContent(e.fault);\r\n                        return new ACYSwapErrorStatus(e.fault);\r\n                    } else {\r\n                        setButtonContent(\"unknow error\");\r\n                        return new ACYSwapErrorStatus(\"unknow error\");\r\n                    }\r\n                }\r\n            }\r\n            setParsedToken0Amount(parsedToken0Amount);\r\n            setParsedToken1Amount(parsedToken1Amount);\r\n\r\n            // check user account balance\r\n            console.log(\"------------------ CHECK BALANCE ------------------\");\r\n            let userToken0Balance = await getUserTokenBalanceRaw(\r\n                token0IsETH\r\n                    ? ETHER\r\n                    : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol),\r\n                account,\r\n                library\r\n            );\r\n\r\n            let userToken1Balance = await getUserTokenBalanceRaw(\r\n                token1IsETH\r\n                    ? ETHER\r\n                    : new Token(chainId, inToken1Address, inToken1Decimal, inToken1Symbol),\r\n                account,\r\n                library\r\n            );\r\n\r\n            console.log(\"token0 balance\");\r\n            console.log(userToken0Balance);\r\n\r\n            console.log(\"token1 balance\");\r\n            console.log(userToken1Balance);\r\n\r\n            let userHasSufficientBalance;\r\n            try {\r\n                userHasSufficientBalance =\r\n                    userToken0Balance.gte(parseUnits(inToken0Amount, inToken0Decimal)) &&\r\n                    userToken1Balance.gte(parseUnits(inToken1Amount, inToken1Decimal));\r\n            }catch(e){\r\n                console.log(userHasSufficientBalance);\r\n                console.log(e);\r\n                setButtonStatus(false);\r\n                if (e.fault === \"underflow\") {\r\n                    setButtonContent(e.fault);\r\n                    return new ACYSwapErrorStatus(e.fault);\r\n                } else {\r\n                    setButtonContent(\"unknow error\");\r\n                    return new ACYSwapErrorStatus(\"unknow error\");\r\n                }\r\n\r\n            }\r\n\r\n            // quit if user doesn't have enough balance, otherwise this will cause error\r\n            if (!userHasSufficientBalance) {\r\n                setButtonContent(\"Not enough balance\");\r\n                setButtonStatus(false);\r\n                return new ACYSwapErrorStatus(\"Not enough balance\");\r\n            }\r\n\r\n\r\n            console.log(\"------------------ BREAKDOWN ------------------\");\r\n            if (!noLiquidity) {\r\n                let totalSupply = await getTokenTotalSupply(\r\n                    pair.liquidityToken,\r\n                    library,\r\n                    account\r\n                );\r\n                console.log(\"Liquidity Minted\");\r\n                console.log(pair.liquidityToken);\r\n\r\n                try {\r\n                    let liquidityMinted = pair.getLiquidityMinted(\r\n                        totalSupply,\r\n                        parsedToken0Amount,\r\n                        parsedToken1Amount\r\n                    );\r\n                    let poolTokenPercentage = new Percent(\r\n                        liquidityMinted.raw,\r\n                        totalSupply.add(liquidityMinted).raw\r\n                    ).toFixed(4);\r\n\r\n                    setLiquidityBreakdown([\r\n                        `Slippage tolerance : ${slippage}%`,\r\n                        `Pool reserve: ${pair.reserve0.toExact()} ${\r\n                            pair.token0.symbol\r\n                        } + ${pair.reserve1.toExact()} ${pair.token1.symbol}`,\r\n                        `Pool share: ${poolTokenPercentage}%`,\r\n                        `${token0.symbol}: ${parsedToken0Amount.toExact()}`,\r\n                        `${token1.symbol}: ${parsedToken1Amount.toExact()}`,\r\n                        // noLiquidity ? \"100\" : `${poolTokenPercentage?.toSignificant(4)}} %`,\r\n                    ]);\r\n\r\n                } catch (e) {\r\n                    if (e instanceof InsufficientReservesError) {\r\n                        setButtonContent(\"Insufficient reserve!\");\r\n                        setButtonStatus(false);\r\n                        // alert(\"something wrong !!!!\");\r\n                        return new ACYSwapErrorStatus(\"Insufficient reserve!\");\r\n                        console.log(\"Insufficient reserve!\");\r\n                    } else {\r\n                        setButtonContent(\"Unhandled exception!\");\r\n                        setButtonStatus(false);\r\n                        return new ACYSwapErrorStatus(\"Unhandled exception!\");\r\n                        console.log(\"Unhandled exception!\");\r\n                        console.log(e);\r\n                    }\r\n                }\r\n            } else {\r\n                setLiquidityBreakdown([\"new pool\"]);\r\n            }\r\n            console.log(\"------------------ ALLOWANCE ------------------\");\r\n            let approveStatus = 0;\r\n            if (!token0IsETH) {\r\n                let token0approval = await checkTokenIsApproved(\r\n                    inToken0Address,\r\n                    parsedToken0Amount.raw.toString(),\r\n                    library,\r\n                    account\r\n                );\r\n                console.log(\"token 0 approved?\");\r\n                console.log(token0approval);\r\n\r\n                if (!token0approval) {\r\n                    console.log(\"Not enough allowance\");\r\n                    setApproveAmountToken0(parsedToken0Amount.raw.toString());\r\n                    setNeedApproveToken0(true);\r\n                    setApproveToken0ButtonShow(true);\r\n                    approveStatus += 1;\r\n                }\r\n            }\r\n            if (!token1IsETH) {\r\n                console.log(\r\n                    `Inside addLiquidity, amount needed: ${parsedToken1Amount.raw.toString()}`\r\n                );\r\n                let token1approval = await checkTokenIsApproved(\r\n                    inToken1Address,\r\n                    parsedToken1Amount.raw.toString(),\r\n                    library,\r\n                    account\r\n                );\r\n                console.log(\"token 1 approved?\");\r\n                console.log(token1approval);\r\n\r\n                if (!token1approval) {\r\n                    console.log(\"Not enough allowance for token1\");\r\n                    setApproveAmountToken1(parsedToken1Amount.raw.toString());\r\n                    setNeedApproveToken1(true);\r\n                    setApproveToken1ButtonShow(true);\r\n                    approveStatus += 2;\r\n                }\r\n            }\r\n            if (approveStatus > 0) {\r\n                setButtonStatus(false);\r\n                setButtonContent(\"need approve\");\r\n\r\n                return new ACYSwapErrorStatus(\r\n                    `Need approve ${\r\n                        approveStatus === 1\r\n                            ? inToken0Symbol\r\n                            : approveStatus === 2\r\n                                ? inToken1Symbol\r\n                                : `${inToken0Symbol} and ${inToken1Symbol}`\r\n                    }`\r\n                );\r\n            }\r\n            setButtonStatus(true);\r\n            if (noLiquidity) {\r\n                setButtonContent(\"create a new pool\");\r\n            } else {\r\n                setButtonContent(\"add liquidity\");\r\n            }\r\n\r\n            console.log(\r\n                \"------------------ PREPARE ADD LIQUIDITY ------------------\"\r\n            );\r\n            console.log(\"parsed token 0 amount\");\r\n            console.log(parsedToken0Amount.raw);\r\n            console.log(\"parsed token 1 amount\");\r\n            console.log(parsedToken1Amount.raw);\r\n            console.log(\"slippage\");\r\n            console.log(allowedSlippage);\r\n\r\n\r\n            let estimate;\r\n            let method;\r\n            let args;\r\n            let value;\r\n\r\n\r\n            if (token0IsETH || token1IsETH) {\r\n                estimate = router.estimateGas.addLiquidityETH;\r\n                method = router.addLiquidityETH;\r\n                let nonETHToken = token0IsETH ? token1 : token0;\r\n\r\n                let parsedNonETHTokenAmount = token0IsETH\r\n                    ? parsedToken1Amount\r\n                    : parsedToken0Amount;\r\n\r\n                let minETH = token0IsETH\r\n                    ? calculateSlippageAmount(\r\n                        parsedToken0Amount,\r\n                        noLiquidity ? 0 : allowedSlippage\r\n                    )[0].toString()\r\n                    : calculateSlippageAmount(\r\n                        parsedToken1Amount,\r\n                        noLiquidity ? 0 : allowedSlippage\r\n                    )[0].toString();\r\n\r\n                args = [\r\n                    nonETHToken.address,\r\n                    parsedNonETHTokenAmount.raw.toString(),\r\n                    calculateSlippageAmount(\r\n                        parsedNonETHTokenAmount,\r\n                        noLiquidity ? 0 : allowedSlippage\r\n                    )[0].toString(),\r\n                    minETH,\r\n                    account,\r\n                    `0x${(Math.floor(new Date().getTime() / 1000) + 60).toString(16)}`,\r\n                ];\r\n                value = BigNumber.from(\r\n                    (token1IsETH ? parsedToken1Amount : parsedToken0Amount).raw.toString()\r\n                );\r\n                console.log(value);\r\n            } else {\r\n                estimate = router.estimateGas.addLiquidity;\r\n                method = router.addLiquidity;\r\n                args = [\r\n                    inToken0Address,\r\n                    inToken1Address,\r\n                    parsedToken0Amount.raw.toString(),\r\n                    parsedToken1Amount.raw.toString(),\r\n                    calculateSlippageAmount(\r\n                        parsedToken0Amount,\r\n                        noLiquidity ? 0 : allowedSlippage\r\n                    )[0].toString(),\r\n                    calculateSlippageAmount(\r\n                        parsedToken1Amount,\r\n                        noLiquidity ? 0 : allowedSlippage\r\n                    )[0].toString(),\r\n                    account,\r\n                    `0x${(Math.floor(new Date().getTime() / 1000) + 60).toString(16)}`,\r\n                ];\r\n                value = null;\r\n            }\r\n            console.log(\"args\");\r\n            console.log(args);\r\n            console.log(\"estimate\");\r\n            console.log(estimate);\r\n            console.log(\"method\");\r\n            console.log(method);\r\n            console.log(\"value\");\r\n            console.log(value);\r\n\r\n            setArgs(args);\r\n            setValue(value);\r\n\r\n\r\n        }//  end of\r\n        // ETH <-> Non-WETH ERC20     OR     Non-WETH ERC20 <-> Non-WETH ERC20\r\n    })();\r\n\r\n    if (status instanceof ACYSwapErrorStatus) {\r\n        console.log(status.getErrorText());\r\n    } else {\r\n        console.log(status);\r\n    }\r\n}\r\n\r\nexport async function addLiquidity(\r\n    inputToken0,\r\n    inputToken1,\r\n    allowedSlippage = INITIAL_ALLOWED_SLIPPAGE,\r\n    exactIn = true,\r\n    chainId,\r\n    library,\r\n    account,\r\n    pair,\r\n    noLiquidity,\r\n    parsedToken0Amount,\r\n    parsedToken1Amount,\r\n    args,\r\n    value,\r\n    setLiquidityStatus\r\n) {\r\n    let status = await (async () => {\r\n        // check uniswap\r\n        console.log(FACTORY_ADDRESS);\r\n        let router = getRouterContract(library, account);\r\n\r\n        const {\r\n            address: inToken0Address,\r\n            symbol: inToken0Symbol,\r\n            decimal: inToken0Decimal,\r\n            amount: inToken0Amount,\r\n        } = inputToken0;\r\n        const {\r\n            address: inToken1Address,\r\n            symbol: inToken1Symbol,\r\n            decimal: inToken1Decimal,\r\n            amount: inToken1Amount,\r\n        } = inputToken1;\r\n\r\n        let token0IsETH = inToken0Symbol === \"ETH\";\r\n        let token1IsETH = inToken1Symbol === \"ETH\";\r\n\r\n\r\n        console.log(\"------------------ RECEIVED TOKEN ------------------\");\r\n        console.log(\"token0\");\r\n        console.log(inputToken0);\r\n        console.log(\"token1\");\r\n        console.log(inputToken1);\r\n\r\n        if (token0IsETH && token1IsETH)\r\n            return new ACYSwapErrorStatus(\"Doesn't support ETH to ETH\");\r\n\r\n        if (\r\n            (token0IsETH && inToken1Symbol === \"WETH\") ||\r\n            (inToken0Symbol === \"WETH\" && token1IsETH)\r\n        ) {\r\n            // UI should sync value of ETH and WETH\r\n            return new ACYSwapErrorStatus(\"Invalid pair WETH/ETH\");\r\n        }\r\n        // ETH <-> Non-WETH ERC20     OR     Non-WETH ERC20 <-> Non-WETH ERC20\r\n        else {\r\n            console.log(\"ADD LIQUIDITY\");\r\n            console.log(\"------------------ CONSTRUCT TOKEN ------------------\");\r\n            // use WETH for ETHER to work with Uniswap V2 SDK\r\n            const token0 = token0IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol);\r\n            const token1 = token1IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken1Address, inToken1Decimal, inToken1Symbol);\r\n\r\n            // quit if the two tokens are equivalent, i.e. have the same chainId and address\r\n            if (token0.equals(token1)) return new ACYSwapErrorStatus(\"Equal tokens!\");\r\n\r\n\r\n            // get pair using our own provider\r\n            console.log(\"------------------ CONSTRUCT PAIR ------------------\");\r\n            console.log(\"FETCH pair\");\r\n            // if an error occurs, because pair doesn't exists\r\n            console.log(pair);\r\n            console.log(noLiquidity);\r\n            console.log(\"------------------ PARSE AMOUNT ------------------\");\r\n            console.log(parsedToken0Amount);\r\n            console.log(parsedToken1Amount);\r\n            console.log(\"------------------ CHECK BALANCE ------------------\");\r\n            console.log(\"------------------ BREAKDOWN ------------------\");\r\n            console.log(\"------------------ ALLOWANCE ------------------\");\r\n            console.log(\"------------------ PREPARE ADD LIQUIDITY ------------------\");\r\n            let estimate;\r\n            let method;\r\n            if (token0IsETH || token1IsETH) {\r\n                estimate = router.estimateGas.addLiquidityETH;\r\n                method = router.addLiquidityETH;\r\n                console.log(args);\r\n                console.log(value);\r\n            } else {\r\n                estimate = router.estimateGas.addLiquidity;\r\n                method = router.addLiquidity;\r\n                console.log(args);\r\n                console.log(value);\r\n            }\r\n\r\n            setLiquidityStatus(\"Processing add liquidity request\");\r\n            console.log(\"parsed token 0 amount\");\r\n            console.log(parsedToken0Amount.raw);\r\n            console.log(\"parsed token 1 amount\");\r\n            console.log(parsedToken1Amount.raw);\r\n            console.log(\"slippage\");\r\n            console.log(allowedSlippage);\r\n\r\n            console.log(estimate);\r\n            console.log(method);\r\n            console.log(args);\r\n            console.log(value);\r\n\r\n            let result = await estimate(...args, value ? {value} : {}).then(\r\n                (estimatedGasLimit) =>\r\n                    method(...args, {\r\n                        ...(value ? {value} : {}),\r\n                        gasLimit: calculateGasMargin(estimatedGasLimit),\r\n                    }).catch((e) => {\r\n                        return new ACYSwapErrorStatus(\"Error in transaction\");\r\n                    })\r\n            );\r\n            return result;\r\n        }\r\n    })();\r\n    if (status instanceof ACYSwapErrorStatus) {\r\n        setLiquidityStatus(status.getErrorText());\r\n    } else {\r\n        console.log(\"status\");\r\n        console.log(status);\r\n        let url = \"https://rinkeby.etherscan.io/tx/\" + status.hash;\r\n        setLiquidityStatus(<a href={url} target={\"_blank\"}>view it on etherscan</a>);\r\n    }\r\n    return;\r\n}\r\n\r\n// expects at least has WETH as one of the tokens\r\nexport async function getAllLiquidityPositions(tokens, chainId, library, account) {\r\n    // we only want WETH\r\n    tokens = tokens.filter((token) => token.symbol !== \"ETH\");\r\n\r\n    let totalTokenCount = tokens.length;\r\n    let userNonZeroLiquidityPositions = [];\r\n\r\n    if (totalTokenCount === 1) return;\r\n\r\n    let checkLiquidityPositionTasks = [];\r\n\r\n    for (let i = 0; i < totalTokenCount; i++) {\r\n        for (let j = i + 1; j < totalTokenCount; j++) {\r\n            const {\r\n                address: token0Address,\r\n                symbol: token0Symbol,\r\n                decimal: token0Decimal,\r\n            } = tokens[i];\r\n            const {\r\n                address: token1Address,\r\n                symbol: token1Symbol,\r\n                decimal: token1Decimal,\r\n            } = tokens[j];\r\n\r\n            const token0 = new Token(\r\n                chainId,\r\n                token0Address,\r\n                token0Decimal,\r\n                token0Symbol\r\n            );\r\n            const token1 = new Token(\r\n                chainId,\r\n                token1Address,\r\n                token1Decimal,\r\n                token1Symbol\r\n            );\r\n\r\n            // quit if the two tokens are equivalent, i.e. have the same chainId and address\r\n            if (token0.equals(token1)) continue;\r\n\r\n            // queue get pair task\r\n            const pairTask = Fetcher.fetchPairData(token0, token1, library);\r\n            checkLiquidityPositionTasks.push(pairTask);\r\n        }\r\n    }\r\n\r\n    let pairs = await Promise.allSettled(checkLiquidityPositionTasks);\r\n\r\n    // now we process the pairs\r\n    for (let pair of pairs) {\r\n        if (pair.status === \"rejected\") continue;\r\n\r\n        pair = pair.value;\r\n\r\n        let userPoolBalance = await getUserTokenBalanceRaw(\r\n            pair.liquidityToken,\r\n            account,\r\n            library\r\n        );\r\n\r\n        if (userPoolBalance.isZero()) continue;\r\n\r\n        userPoolBalance = new TokenAmount(pair.liquidityToken, userPoolBalance);\r\n\r\n        let totalPoolTokens = await getTokenTotalSupply(\r\n            pair.liquidityToken,\r\n            library,\r\n            account\r\n        );\r\n\r\n        let token0Deposited = pair.getLiquidityValue(\r\n            pair.token0,\r\n            totalPoolTokens,\r\n            userPoolBalance,\r\n            false\r\n        );\r\n        let token1Deposited = pair.getLiquidityValue(\r\n            pair.token1,\r\n            totalPoolTokens,\r\n            userPoolBalance,\r\n            false\r\n        );\r\n\r\n        let totalSupply = await getTokenTotalSupply(\r\n            pair.liquidityToken,\r\n            library,\r\n            account\r\n        );\r\n\r\n        // let liquidityMinted = pair.getLiquidityMinted(\r\n        //     totalSupply,\r\n        //     token0Deposited,\r\n        //     token1Deposited\r\n        // );\r\n\r\n        let poolTokenPercentage = new Percent(\r\n            userPoolBalance.raw,\r\n            totalSupply.raw\r\n        ).toFixed(4);\r\n\r\n        userNonZeroLiquidityPositions.push({\r\n            pool: `${pair.token0.symbol}/${pair.token1.symbol}`,\r\n            token0Amount: `${token0Deposited.toSignificant(6)} ${pair.token0.symbol}`,\r\n            token1Amount: `${token1Deposited.toSignificant(6)} ${pair.token1.symbol}`,\r\n            token0Reserve: `${pair.reserve0.toExact()} ${pair.token0.symbol}`,\r\n            token1Reserve: `${pair.reserve1.toExact()} ${pair.token1.symbol}`,\r\n            share: `${poolTokenPercentage}%`,\r\n        });\r\n    }\r\n\r\n    console.log(\"token pairs that user has positions:\");\r\n    console.log(userNonZeroLiquidityPositions);\r\n    return userNonZeroLiquidityPositions;\r\n}\r\n\r\nconst LiquidityComponent = () => {\r\n    let [token0, setToken0] = useState(null);\r\n    let [token1, setToken1] = useState(null);\r\n    let [token0Balance, setToken0Balance] = useState(\"not know yet\");\r\n    let [token1Balance, setToken1Balance] = useState(\"not know yet\");\r\n    let [token0Amount, setToken0Amount] = useState(\"0\");\r\n    let [token1Amount, setToken1Amount] = useState(\"0\");\r\n    let [token0BalanceShow, setToken0BalanceShow] = useState(false);\r\n    let [token1BalanceShow, setToken1BalanceShow] = useState(false);\r\n\r\n    // true 指前面的，false指后面的\r\n    let [exactIn, setExactIn] = useState(true);\r\n    let [slippageTolerance, setSlippageTolerance] = useState(INITIAL_ALLOWED_SLIPPAGE / 100);\r\n\r\n    let [needApproveToken0, setNeedApproveToken0] = useState(false);\r\n    let [needApproveToken1, setNeedApproveToken1] = useState(false);\r\n    let [approveAmountToken0, setApproveAmountToken0] = useState(\"0\");\r\n    let [approveAmountToken1, setApproveAmountToken1] = useState(\"0\");\r\n\r\n    let [approveToken0ButtonShow, setApproveToken0ButtonShow] = useState(false);\r\n    let [approveToken1ButtonShow, setApproveToken1ButtonShow] = useState(false);\r\n\r\n\r\n    let [liquidityBreakdown, setLiquidityBreakdown] = useState();\r\n    let [buttonContent, setButtonContent] = useState(\"connect to wallet\");\r\n    let [buttonStatus, setButtonStatus] = useState(true);\r\n    let [liquidityStatus, setLiquidityStatus] = useState();\r\n\r\n    let [pair, setPair] = useState();\r\n    let [noLiquidity, setNoLiquidity] = useState();\r\n    let [parsedToken0Amount, setParsedToken0Amount] = useState();\r\n    let [parsedToken1Amount, setParsedToken1Amount] = useState();\r\n\r\n    let [args, setArgs] = useState();\r\n    let [value, setValue] = useState();\r\n\r\n\r\n    let [userLiquidityPositions, setUserLiquidityPositions] = useState([]);\r\n\r\n    const individualFieldPlaceholder = \"Enter amount\";\r\n    const dependentFieldPlaceholder = \"Estimated value\";\r\n    const slippageTolerancePlaceholder = \"please input a number from 1.00 to 100.00\";\r\n\r\n    const {account, chainId, library, activate} = useWeb3React();\r\n    const injected = new InjectedConnector({\r\n        supportedChainIds: [1, 3, 4, 5, 42, 80001],\r\n    });\r\n\r\n\r\n    useEffect(() => {\r\n        // activate(injected);\r\n    }, []);\r\n\r\n    let t0Changed = useCallback(async () => {\r\n        if (!token0 || !token1) return;\r\n        if (!exactIn) return;\r\n        await getEstimated(\r\n            {\r\n                ...token0,\r\n                amount: token0Amount,\r\n            },\r\n            {\r\n                ...token1,\r\n                amount: token1Amount,\r\n            },\r\n            slippageTolerance * 100,\r\n            exactIn,\r\n            chainId,\r\n            library,\r\n            account,\r\n            setToken0Amount,\r\n            setToken1Amount,\r\n            setNeedApproveToken0,\r\n            setNeedApproveToken1,\r\n            setApproveAmountToken0,\r\n            setApproveAmountToken1,\r\n            setApproveToken0ButtonShow,\r\n            setApproveToken1ButtonShow,\r\n            setLiquidityBreakdown,\r\n            setButtonContent,\r\n            setButtonStatus,\r\n            setLiquidityStatus,\r\n            setPair,\r\n            setNoLiquidity,\r\n            setParsedToken0Amount,\r\n            setParsedToken1Amount,\r\n            setArgs,\r\n            setValue);\r\n\r\n    }, [token0, token1, token0Amount, token1Amount, slippageTolerance,exactIn, chainId, library, account]);\r\n    let t1Changed = useCallback(async () => {\r\n        if (!token0 || !token1) return;\r\n        if (exactIn) return;\r\n        await getEstimated(\r\n            {\r\n                ...token0,\r\n                amount: token0Amount,\r\n            },\r\n            {\r\n                ...token1,\r\n                amount: token1Amount,\r\n            },\r\n            slippageTolerance * 100,\r\n            exactIn,\r\n            chainId,\r\n            library,\r\n            account,\r\n            setToken0Amount,\r\n            setToken1Amount,\r\n            setNeedApproveToken0,\r\n            setNeedApproveToken1,\r\n            setApproveAmountToken0,\r\n            setApproveAmountToken1,\r\n            setApproveToken0ButtonShow,\r\n            setApproveToken1ButtonShow,\r\n            setLiquidityBreakdown,\r\n            setButtonContent,\r\n            setButtonStatus,\r\n            setLiquidityStatus,\r\n            setPair,\r\n            setNoLiquidity,\r\n            setParsedToken0Amount,\r\n            setParsedToken1Amount,\r\n            setArgs,\r\n            setValue);\r\n    }, [token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account]);\r\n    useEffect(() => {\r\n        t0Changed();\r\n    }, [token0, token1, token0Amount, token1Amount, slippageTolerance,exactIn, chainId, library, account]);\r\n    useEffect(() => {\r\n        t1Changed();\r\n    }, [token0, token1, token0Amount, token1Amount, slippageTolerance,exactIn, chainId, library, account]);\r\n\r\n\r\n    useEffect(() => {\r\n        if (account == undefined) {\r\n            setButtonStatus(true);\r\n            setButtonContent(\"Connect to Wallet\");\r\n        } else {\r\n            setButtonContent(\"choose tokens and amount\");\r\n            setButtonStatus(false);\r\n        }\r\n    }, [chainId, library, account]);\r\n\r\n    useEffect(() => {\r\n        async function getAllUserLiquidityPositions() {\r\n            if (account != undefined) {\r\n                setUserLiquidityPositions(\r\n                    await getAllLiquidityPositions(\r\n                        supportedTokens,\r\n                        chainId,\r\n                        library,\r\n                        account\r\n                    )\r\n                );\r\n            }\r\n        }\r\n\r\n        getAllUserLiquidityPositions();\r\n    }, [chainId, library, account]);\r\n\r\n\r\n    return (\r\n        <div>\r\n            <h1>Add liquidity</h1>\r\n            <Form>\r\n                <Form.Group className=\"mb-3\" controlId=\"formBasicEmail\">\r\n                    <Dropdown>\r\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\r\n                            {(token0 && token0.symbol) || \"In token\"}\r\n                        </Dropdown.Toggle>\r\n\r\n                        <Dropdown.Menu>\r\n                            {supportedTokens.map((token, index) => (\r\n                                <Dropdown.Item\r\n                                    key={index}\r\n                                    onClick={async () => {\r\n                                        if (account == undefined) {\r\n                                            alert(\"please connect to your account\");\r\n                                        } else {\r\n                                            setToken0(token);\r\n                                            setToken0Balance(\r\n                                                await getUserTokenBalance(\r\n                                                    token,\r\n                                                    chainId,\r\n                                                    account,\r\n                                                    library\r\n                                                )\r\n                                            );\r\n                                            setToken0BalanceShow(true);\r\n                                        }\r\n                                    }}\r\n                                >\r\n                                    {token.symbol}\r\n                                </Dropdown.Item>\r\n                            ))}\r\n                        </Dropdown.Menu>\r\n                    </Dropdown>\r\n                    <Form.Control\r\n                        value={token0Amount}\r\n                        placeholder={\r\n                            exactIn ? individualFieldPlaceholder : dependentFieldPlaceholder\r\n                        }\r\n                        onChange={(e) => {\r\n                            setExactIn(true);\r\n                            setToken0Amount(e.target.value);\r\n                        }}\r\n                    />\r\n                    {token0BalanceShow ?\r\n                        <small>Balance: {token0Balance}</small> :\r\n                        <small>not know yet</small>\r\n                    }\r\n                </Form.Group>\r\n                <Form.Group className=\"mb-3\" controlId=\"formBasicPassword\">\r\n                    <Dropdown>\r\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\r\n                            {(token1 && token1.symbol) || \"Out token\"}\r\n                        </Dropdown.Toggle>\r\n\r\n                        <Dropdown.Menu>\r\n                            {supportedTokens.map((token, index) => (\r\n                                <Dropdown.Item\r\n                                    key={index}\r\n                                    onClick={async () => {\r\n                                        if (account == undefined) {\r\n                                            alert(\"please connect to your account\");\r\n                                        } else {\r\n                                            setToken1(token);\r\n                                            setToken1Balance(\r\n                                                await getUserTokenBalance(\r\n                                                    token,\r\n                                                    chainId,\r\n                                                    account,\r\n                                                    library\r\n                                                )\r\n                                            );\r\n                                            setToken1BalanceShow(true);\r\n                                        }\r\n                                    }}\r\n                                >\r\n                                    {token.symbol}\r\n                                </Dropdown.Item>\r\n                            ))}\r\n                        </Dropdown.Menu>\r\n                    </Dropdown>\r\n                    <Form.Control\r\n                        value={token1Amount}\r\n                        placeholder={\r\n                            exactIn ? dependentFieldPlaceholder : individualFieldPlaceholder\r\n                        }\r\n                        onChange={(e) => {\r\n                            setExactIn(false);\r\n                            setToken1Amount(e.target.value);\r\n                        }}\r\n                    />\r\n                    {token1BalanceShow ?\r\n                        <small>Balance: {token1Balance}</small> :\r\n                        <small>not know yet</small>\r\n                    }\r\n                </Form.Group>\r\n                <InputGroup size=\"sm\" className=\"mb-3\">\r\n                    <InputGroup.Text id=\"inputGroup-sizing-sm\">Slippage tolerance </InputGroup.Text>\r\n                    <FormControl\r\n                        aria-label=\"Small\"\r\n                        aria-describedby=\"inputGroup-sizing-sm\"\r\n                        placeholder={slippageTolerancePlaceholder}\r\n                        onChange={(e => {\r\n                            setSlippageTolerance(e.target.value);\r\n                        })}\r\n\r\n                    />\r\n                    <InputGroup.Text>%</InputGroup.Text>\r\n                </InputGroup>\r\n                <Alert variant=\"danger\">\r\n                    the Slippage Tolerance you choose is [ {slippageTolerance}% ]\r\n                </Alert>\r\n\r\n\r\n                <Alert variant=\"primary\">\r\n                    {liquidityBreakdown && <mark>liquidity breakdown</mark>}\r\n                    {liquidityBreakdown && liquidityBreakdown.map((info) => <p>{info}</p>)}\r\n                </Alert>\r\n\r\n\r\n                {/* APPROVE BUTTONS */}\r\n                {\r\n                    approveToken0ButtonShow == true && <mark>\r\n                        <Button\r\n                            variant=\"warning\"\r\n                            onClick={async () => {\r\n\r\n                                \r\n                                let state = await approve(token0.address, approveAmountToken0, library, account);\r\n                                \r\n                                if (state == true) {\r\n                                 \r\n                                    setNeedApproveToken0(false);\r\n\r\n                                    await getEstimated(\r\n                                        {\r\n                                            ...token0,\r\n                                            amount: token0Amount,\r\n                                        },\r\n                                        {\r\n                                            ...token1,\r\n                                            amount: token1Amount,\r\n                                        },\r\n                                        slippageTolerance * 100,\r\n                                        exactIn,\r\n                                        chainId,\r\n                                        library,\r\n                                        account,\r\n                                        setToken0Amount,\r\n                                        setToken1Amount,\r\n                                        setNeedApproveToken0,\r\n                                        setNeedApproveToken1,\r\n                                        setApproveAmountToken0,\r\n                                        setApproveAmountToken1,\r\n                                        setApproveToken0ButtonShow,\r\n                                        setApproveToken1ButtonShow,\r\n                                        setLiquidityBreakdown,\r\n                                        setButtonContent,\r\n                                        setButtonStatus,\r\n                                        setLiquidityStatus,\r\n                                        setPair,\r\n                                        setNoLiquidity,\r\n                                        setParsedToken0Amount,\r\n                                        setParsedToken1Amount,\r\n                                        setArgs,\r\n                                        setValue);\r\n\r\n\r\n\r\n                                    if (needApproveToken1 == false) {\r\n                                        if (!noLiquidity) setButtonContent(\"add liquidity\");\r\n                                        else setButtonStatus(\"create new pool\");\r\n                                        setButtonStatus(true);\r\n                                    }\r\n\r\n                                }\r\n                            }}\r\n                            disabled={!needApproveToken0}\r\n                        >\r\n                            Approve {token0 && token0.symbol}\r\n                        </Button>\r\n                        {' '}\r\n                    </mark>\r\n                }\r\n                {\r\n                    approveToken1ButtonShow == true && <mark>\r\n                        <Button\r\n                            variant=\"warning\"\r\n                            onClick={async () => {\r\n                                let state = await approve(token1.address, approveAmountToken1, library, account);\r\n\r\n                                if (state == true) {\r\n                                    // console.log(\"TTTTTTTTTTTTTTTTTTTTTTT\");\r\n                                    // alert(\"TTTTTTTTTTTTTT\");\r\n                                    setNeedApproveToken1(false);\r\n\r\n                                    await getEstimated(\r\n                                        {\r\n                                            ...token0,\r\n                                            amount: token0Amount,\r\n                                        },\r\n                                        {\r\n                                            ...token1,\r\n                                            amount: token1Amount,\r\n                                        },\r\n                                        slippageTolerance * 100,\r\n                                        exactIn,\r\n                                        chainId,\r\n                                        library,\r\n                                        account,\r\n                                        setToken0Amount,\r\n                                        setToken1Amount,\r\n                                        setNeedApproveToken0,\r\n                                        setNeedApproveToken1,\r\n                                        setApproveAmountToken0,\r\n                                        setApproveAmountToken1,\r\n                                        setApproveToken0ButtonShow,\r\n                                        setApproveToken1ButtonShow,\r\n                                        setLiquidityBreakdown,\r\n                                        setButtonContent,\r\n                                        setButtonStatus,\r\n                                        setLiquidityStatus,\r\n                                        setPair,\r\n                                        setNoLiquidity,\r\n                                        setParsedToken0Amount,\r\n                                        setParsedToken1Amount,\r\n                                        setArgs,\r\n                                        setValue);\r\n                                    if (needApproveToken0 == false) {\r\n                                        if (!noLiquidity) setButtonContent(\"add liquidity\");\r\n                                        else setButtonStatus(\"create new pool\");\r\n                                        setButtonStatus(true);\r\n                                    }\r\n                                }\r\n                            }}\r\n                            disabled={!needApproveToken1}\r\n                        >\r\n                            Approve {token1 && token1.symbol}\r\n                        </Button>\r\n                        {' '}\r\n                    </mark>\r\n                }\r\n                <Button\r\n                    variant=\"success\"\r\n                    disabled={!buttonStatus}\r\n                    onClick={async () => {\r\n                        if (account == undefined) {\r\n                            activate(injected);\r\n                            setButtonContent(\"choose tokens and amount\");\r\n                            setButtonStatus(false);\r\n                        } else {\r\n                            await addLiquidity(\r\n                                {\r\n                                    ...token0,\r\n                                    amount: token0Amount,\r\n                                },\r\n                                {\r\n                                    ...token1,\r\n                                    amount: token1Amount,\r\n                                },\r\n                                100 * slippageTolerance,\r\n                                exactIn,\r\n                                chainId,\r\n                                library,\r\n                                account,\r\n                                pair,\r\n                                noLiquidity,\r\n                                parsedToken0Amount,\r\n                                parsedToken1Amount,\r\n                                args,\r\n                                value,\r\n                                setLiquidityStatus\r\n                            );\r\n\r\n                        }\r\n                    }\r\n                    }\r\n                >\r\n                    {buttonContent}\r\n                </Button>\r\n                <Alert variant=\"primary\">\r\n                    {liquidityStatus && <mark> liquidityStatus:</mark>}\r\n                    {liquidityStatus && <p> {liquidityStatus}</p>}\r\n                </Alert>\r\n\r\n                <h2>Your positions</h2>\r\n                {userLiquidityPositions.map((position) => (\r\n                    <Alert variant=\"dark\">\r\n                        {Object.values(position).map((field) => (\r\n                            <p>{field}</p>\r\n                        ))}\r\n                    </Alert>\r\n                ))}\r\n            </Form>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default LiquidityComponent;\r\n","D:\\GitHub\\acy-dex-swap\\src\\components\\RemoveLiquidityComponent.js",["95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121"],"import {useWeb3React} from \"@web3-react/core\";\r\nimport {InjectedConnector} from \"@web3-react/injected-connector\";\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport {useCallback, useEffect, useState} from \"react\";\r\nimport {Alert, Button, Dropdown, Form, FormControl, InputGroup} from \"react-bootstrap\";\r\nimport {\r\n    ACYSwapErrorStatus,\r\n    approve,\r\n    calculateGasMargin,\r\n    calculateSlippageAmount,\r\n    checkTokenIsApproved,\r\n    getAllowance,\r\n    getPairContract,\r\n    getRouterContract,\r\n    getTokenTotalSupply,\r\n    getUserTokenBalanceRaw,\r\n    INITIAL_ALLOWED_SLIPPAGE,\r\n    ROUTER_ADDRESS,\r\n    supportedTokens\r\n} from \"../utils\";\r\nimport {ETHER, Fetcher, Percent, Token, TokenAmount, WETH,CurrencyAmount} from \"@uniswap/sdk\";\r\n\r\n\r\nimport {BigNumber} from \"@ethersproject/bignumber\";\r\nimport {parseUnits} from \"@ethersproject/units\";\r\nimport {splitSignature} from \"@ethersproject/bytes\";\r\n\r\n// 现在的版本里没有用到\r\nexport async function getPositionAndBalance(\r\n    inToken0,\r\n    inToken1,\r\n    chainId,\r\n    account,\r\n    library,\r\n    setBalance,\r\n    setBalanceShow,\r\n    setPosition\r\n) \r\n{\r\n    setBalance(\"0\");\r\n    setBalanceShow(false);\r\n    setPosition(\"\");\r\n\r\n    let {\r\n        address: inToken0Address,\r\n        symbol: inToken0Symbol,\r\n        decimal: inToken0Decimal,\r\n    } = inToken0;\r\n    let {\r\n        address: inToken1Address,\r\n        symbol: inToken1Symbol,\r\n        decimal: inToken1Decimal,\r\n    } = inToken1;\r\n\r\n\r\n    const token0 = new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol);\r\n    const token1 = new Token(chainId, inToken1Address, inToken1Decimal, inToken1Symbol);\r\n\r\n    if (token0.equals(token1)) {\r\n        setBalance(\"0\");\r\n        setBalanceShow(false);\r\n        setPosition(['tokens can\\'t be the same']);\r\n        return;\r\n    }\r\n\r\n    let checkLiquidityPositionTasks = [];\r\n    let userNonZeroLiquidityPositions = [];\r\n\r\n    // queue get pair task\r\n    const pairTask = Fetcher.fetchPairData(token0, token1, library);\r\n    checkLiquidityPositionTasks.push(pairTask);\r\n\r\n    let pairs = await Promise.allSettled(checkLiquidityPositionTasks);\r\n\r\n    for (let pair of pairs) {\r\n        if (pair.status === \"rejected\") {\r\n            setBalance(\"0\");\r\n            setBalanceShow(false);\r\n            setPosition([\"this pair's fetch is reject\"]);\r\n            return;\r\n        }\r\n        pair = pair.value;\r\n\r\n        let first = new TokenAmount(token0, parseUnits(\"1\", inToken0Decimal));\r\n        let firstPrice = pair.priceOf(token0).quote(first);\r\n        let second = new TokenAmount(token1, parseUnits(\"1\", inToken1Decimal));\r\n        let secondPrice = pair.priceOf(token1).quote(second);\r\n\r\n        let userPoolBalance = await getUserTokenBalanceRaw(pair.liquidityToken, account, library);\r\n        if (userPoolBalance.isZero()) {\r\n            setBalance(\"0\");\r\n            setBalanceShow(true);\r\n            setPosition([\"user pool balance is zero\"]);\r\n            return;\r\n        }\r\n\r\n        userPoolBalance = new TokenAmount(pair.liquidityToken, userPoolBalance);\r\n        let totalPoolTokens = await getTokenTotalSupply(pair.liquidityToken, library, account);\r\n        let token0Deposited = pair.getLiquidityValue(pair.token0, totalPoolTokens, userPoolBalance, false);\r\n        let token1Deposited = pair.getLiquidityValue(pair.token1, totalPoolTokens, userPoolBalance, false);\r\n        let totalSupply = await getTokenTotalSupply(pair.liquidityToken, library, account);\r\n\r\n        console.log(token0Deposited);\r\n\r\n        /*\r\n        不能把getLiquidityValue的结果作为getLiquiditMinted的输入值\r\n        let liquidityMinted = pair.getLiquidityMinted(\r\n            totalSupply,\r\n            token0Deposited,\r\n            token1Deposited\r\n        );\r\n         */\r\n        let poolTokenPercentage = new Percent(userPoolBalance.raw, totalSupply.raw).toFixed(4);\r\n\r\n        console.log(\"user pool balance\");\r\n        console.log(userPoolBalance);\r\n//        console.log(liquidityMinted.toExact());\r\n        console.log(totalSupply.toExact());\r\n\r\n        console.log(\"symbol\");\r\n//        console.log(liquidityMinted.token.symbol);\r\n\r\n        userNonZeroLiquidityPositions.push([\r\n            `pool: ${pair.token0.symbol}/${pair.token1.symbol}`,\r\n            `pool balance: ${userPoolBalance.toExact()}/${userPoolBalance.token.symbol}`,\r\n            `token0Balance: ${token0Deposited.toSignificant(6)} ${pair.token0.symbol}`,\r\n            `token1Balance: ${token1Deposited.toSignificant(6)} ${pair.token1.symbol}`,\r\n            `token0Reserve: ${pair.reserve0.toExact()} ${pair.token0.symbol}`,\r\n            `token1Reserve: ${pair.reserve1.toExact()} ${pair.token1.symbol}`,\r\n            `price0: 1${inToken0Symbol} = ${firstPrice.toExact()} ${inToken1Symbol}`,\r\n            `price1: 1${inToken1Symbol} = ${secondPrice.toExact()} ${inToken0Symbol}`,\r\n            `share: ${poolTokenPercentage}%`,\r\n        ]);\r\n\r\n        console.log(\"token pairs that user has positions:\");\r\n        console.log(userNonZeroLiquidityPositions);\r\n\r\n        // setToken0Balance(`${token0Deposited.toSignificant(6)} ${pair.token0.symbol}`);\r\n        // setToken1Balance(`${token1Deposited.toSignificant(6)} ${pair.token1.symbol}`);\r\n\r\n        setBalance(userPoolBalance.toExact() + ' ' + userPoolBalance.token.symbol);\r\n        setBalanceShow(true);\r\n        setPosition(userNonZeroLiquidityPositions[0]);\r\n        return;\r\n    }\r\n}\r\n\r\n\r\n// get the estimated amount of the other token required when adding liquidity, in readable string.\r\nexport async function getEstimated(\r\n    inputToken0,\r\n    inputToken1, // 这里是不包含amount信息的\r\n    token0Amount,\r\n    token1Amount,\r\n    index,\r\n    percent,\r\n    amount,\r\n    chainId,\r\n    library,\r\n    account,\r\n    setToken0Amount,\r\n    setToken1Amount,\r\n    setBalance,\r\n    setBalanceShow,\r\n    setPercent,\r\n    setAmount,\r\n    setBreakdown,\r\n    setNeedApprove,\r\n    setButtonStatus,\r\n    setButtonContent,\r\n    setRemoveStatus\r\n) {\r\n    let {\r\n        address: inToken0Address,\r\n        symbol: inToken0Symbol,\r\n        decimal: inToken0Decimal,\r\n    } = inputToken0;\r\n    let {\r\n        address: inToken1Address,\r\n        symbol: inToken1Symbol,\r\n        decimal: inToken1Decimal,\r\n    } = inputToken1;\r\n\r\n    if (!inToken0Symbol || !inToken1Symbol) {\r\n        setToken0Amount(\"0\");\r\n        setToken1Amount(\"0\");\r\n        setBalance(\"0\");\r\n        setBalanceShow(false);\r\n        setNeedApprove(false);\r\n        setButtonStatus(false);\r\n        setButtonContent(\"one or more token is missing\");\r\n        return false;\r\n    }\r\n    //init\r\n    setToken0Amount(\"loading...\")\r\n    setToken1Amount(\"loading...\");\r\n    setBalance(\"0\")\r\n    setBalanceShow(false);\r\n    setBreakdown(\"\");\r\n    setNeedApprove(false);\r\n    setButtonStatus(false);\r\n    setButtonContent(\"loading...\");\r\n    setRemoveStatus(\"\");\r\n\r\n    let token0IsETH = inToken0Symbol === \"ETH\";\r\n    let token1IsETH = inToken1Symbol === \"ETH\";\r\n    if (token0IsETH && token1IsETH) {\r\n        setToken0Amount(\"0\");\r\n        setToken1Amount(\"0\");\r\n        setNeedApprove(false);\r\n        setButtonStatus(false);\r\n        setButtonContent(\"the tokens are both ETH\");\r\n        return;\r\n    }\r\n    if (\r\n        (token0IsETH && inToken1Symbol === \"WETH\") ||\r\n        (inToken0Symbol === \"WETH\" && token1IsETH)\r\n    ) {\r\n        setToken0Amount(\"0\");\r\n        setToken1Amount(\"0\");\r\n        setNeedApprove(false);\r\n        setButtonStatus(false);\r\n        setButtonContent(\"invalid pair of ETH/WETH\");\r\n        return;\r\n    }\r\n    // ETH <-> Non-WETH ERC20     OR     Non-WETH ERC20 <-> Non-WETH ERC20\r\n    else {\r\n        // use WETH for ETHER to work with Uniswap V2 SDK\r\n        const token0 = token0IsETH\r\n            ? WETH[chainId]\r\n            : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol);\r\n        const token1 = token1IsETH\r\n            ? WETH[chainId]\r\n            : new Token(chainId, inToken1Address, inToken1Decimal, inToken1Symbol);\r\n\r\n        if (token0.equals(token1)) {\r\n            setToken0Amount(\"0\");\r\n            setToken1Amount(\"0\");\r\n            setBalanceShow(false);\r\n            setNeedApprove(false);\r\n            setButtonStatus(false);\r\n            setButtonContent(\"tokens can't be the same\");\r\n            return;\r\n        }\r\n\r\n        // get pair using our own provider\r\n        let pair = await Fetcher.fetchPairData(token0, token1, library)\r\n            .then((pair) => {\r\n                console.log(pair.reserve0.raw.toString());\r\n                console.log(pair.reserve1.raw.toString());\r\n                return pair;\r\n            })\r\n            .catch((e) => {\r\n                return new ACYSwapErrorStatus(\r\n                    `${token0.symbol} - ${token1.symbol} pool does not exist. Create one?`\r\n                );\r\n            });\r\n        if (pair instanceof ACYSwapErrorStatus) {\r\n            setToken0Amount(\"0\");\r\n            setToken1Amount(\"0\");\r\n            setBalance(\"\");\r\n            setBalanceShow(false);\r\n            setNeedApprove(false);\r\n            setButtonStatus(false);\r\n            setButtonContent(\"pool does not exist\");\r\n            return;\r\n        }\r\n\r\n        console.log(\"this is pair\");\r\n        console.log(pair);\r\n// 流动性代币的总量\r\n        let totalPoolTokens = await getTokenTotalSupply(\r\n            pair.liquidityToken,\r\n            library,\r\n            account\r\n        );\r\n\r\n        let userPoolBalance = await getUserTokenBalanceRaw(\r\n            pair.liquidityToken,\r\n            account,\r\n            library\r\n        );\r\n\r\n        if(userPoolBalance.isZero()){\r\n            setToken0Amount(\"0\");\r\n            setToken1Amount(\"0\");\r\n            setBalance(\"0\");\r\n            setBalanceShow(true);\r\n            setNeedApprove(false);\r\n            setButtonStatus(false);\r\n            setButtonContent(\"user pool balance is zero\");\r\n            return;\r\n        }\r\n        // 用户拥有的流动性代币\r\n        userPoolBalance = new TokenAmount(pair.liquidityToken, userPoolBalance);\r\n\r\n        console.log(userPoolBalance);\r\n        console.log(userPoolBalance.toExact());\r\n\r\n        setBalance(userPoolBalance.toExact());\r\n        setBalanceShow(true);\r\n\r\n        console.log(token0);\r\n        console.log(pair.token0);\r\n        console.log(token0==pair.token0);\r\n\r\n\r\n        let token0Deposited = pair.getLiquidityValue(\r\n            token0,\r\n            totalPoolTokens,\r\n            userPoolBalance,\r\n            false\r\n        );\r\n        let token1Deposited = pair.getLiquidityValue(\r\n            token1,\r\n            totalPoolTokens,\r\n            userPoolBalance,\r\n            false\r\n        );\r\n        console.log(token0Deposited);\r\n        console.log(token1Deposited);\r\n\r\n        // 这个也是用户拥有的流动代币的总值？\r\n        /*\r\n        这是错误的，因为getLiquidityValue的输出不能作为 liqudityMinted的输入\r\n        let liquidityMinted = pair.getLiquidityMinted(\r\n            totalSupply,\r\n            token0Deposited,\r\n            token1Deposited\r\n        );\r\n        */\r\n\r\n        console.log(\"----------------------------\");\r\n        console.log(userPoolBalance.raw);\r\n        console.log(userPoolBalance.toExact());\r\n\r\n        let liquidityAmount;\r\n        let percentToRemove;\r\n\r\n        if (index === 0) {\r\n            let shang = percent * 100;\r\n            percentToRemove = new Percent(\r\n                shang.toString(),\r\n                \"10000\"\r\n            );\r\n\r\n            console.log(\"shoe percentToMove\");\r\n            console.log(shang.toString());\r\n            console.log(\"10000\");\r\n            console.log(percentToRemove.toSignificant());\r\n\r\n            liquidityAmount = new TokenAmount(\r\n                userPoolBalance.token,\r\n                percentToRemove.multiply(userPoolBalance.raw).quotient\r\n            );\r\n\r\n            setAmount(liquidityAmount.toExact());\r\n\r\n\r\n        } else {\r\n            liquidityAmount = new TokenAmount(\r\n                userPoolBalance.token,\r\n                parseUnits(amount, userPoolBalance.token.decimals)\r\n            );\r\n\r\n           percentToRemove = new Percent(\r\n                liquidityAmount.raw,\r\n                userPoolBalance.raw\r\n            );\r\n            console.log(\"hello\");\r\n            console.log(liquidityAmount.raw);\r\n            console.log(userPoolBalance.raw);\r\n            setPercent(percentToRemove.toSignificant(2));\r\n        }\r\n\r\n        let first = new TokenAmount(token0, parseUnits(\"1\", inToken0Decimal));\r\n        let firstPrice = pair.priceOf(token0).quote(first);\r\n        let second = new TokenAmount(token1, parseUnits(\"1\", inToken1Decimal));\r\n        let secondPrice = pair.priceOf(token1).quote(second);\r\n\r\n        let token0TokenAmount = new TokenAmount(\r\n            token0,\r\n            percentToRemove.multiply(token0Deposited.raw).quotient\r\n        );\r\n\r\n        let token1TokenAmount = new TokenAmount(\r\n            token1,\r\n            percentToRemove.multiply(token1Deposited.raw).quotient\r\n        );\r\n\r\n        let parsedToken0Amount;\r\n        let parsedToken1Amount;\r\n\r\n        parsedToken0Amount =\r\n            token0 === ETHER\r\n                ? CurrencyAmount.ether(token0TokenAmount.raw)\r\n                : token0TokenAmount;\r\n        parsedToken1Amount =\r\n            token1 === ETHER\r\n                ? CurrencyAmount.ether(token1TokenAmount.raw)\r\n                : token1TokenAmount;\r\n\r\n        setToken0Amount(parsedToken0Amount.toExact());\r\n        setToken1Amount(parsedToken1Amount.toExact());\r\n\r\n\r\n\r\n\r\n\r\n        setBreakdown([\r\n            'you will receive',\r\n            `${parsedToken0Amount.toExact()} ${token0.symbol}`,\r\n            `${parsedToken1Amount.toExact()} ${token1.symbol}`,\r\n            `Output is estimated. If the price changes by more than 0.5% your transaction will revert.`,\r\n            `pair token burned  ${amount}`,\r\n            `price0: 1${inToken0Symbol} = ${firstPrice.toExact()} ${inToken1Symbol}`,\r\n            `price1: 1${inToken1Symbol} = ${secondPrice.toExact()} ${inToken0Symbol}`,\r\n        ]);\r\n\r\n        console.log(\"CHECK IF HAVE ENOUGH BALANCE\");\r\n        console.log(pair.liquidityToken);\r\n        let pairBalance = await getUserTokenBalanceRaw(\r\n            pair.liquidityToken,\r\n            account,\r\n            library\r\n        );\r\n        let needAmount = parseUnits(amount,pair.liquidityToken.decimals);\r\n        console.log(pairBalance);\r\n        console.log(needAmount);\r\n\r\n        let  userHasSufficientBalance =pairBalance.gte(\r\n            needAmount\r\n        );\r\n\r\n\r\n        if(!userHasSufficientBalance){\r\n            setNeedApprove(false);\r\n            setButtonStatus(false);\r\n            setButtonContent(\"not enough balance\");\r\n            return ;\r\n        }\r\n\r\n        console.log(\"GET ALLOWANCE\");\r\n        let liquidityApproval = await checkTokenIsApproved(\r\n            liquidityAmount.token.address,\r\n            liquidityAmount.raw.toString(),\r\n            library,\r\n            account\r\n        );\r\n\r\n        if (!liquidityApproval) {\r\n            setNeedApprove(true);\r\n            setButtonStatus(false);\r\n            setButtonContent(\"need approve\");\r\n            return;\r\n        }\r\n\r\n        setNeedApprove(false);\r\n        setButtonStatus(true);\r\n        setButtonContent(\"remove Liquidity\");\r\n        return;\r\n    }\r\n    return;\r\n\r\n}\r\n\r\n\r\nexport async function signOrApprove(\r\n    inputToken0,\r\n    inputToken1,\r\n    index,\r\n    percent,\r\n    amount,\r\n    allowedSlippage = INITIAL_ALLOWED_SLIPPAGE,\r\n    chainId,\r\n    library,\r\n    account,\r\n    setNeedApprove,\r\n    setButtonStatus,\r\n    setButtonContent,\r\n    setRemoveStatus,\r\n    setSignatureData\r\n) {\r\n    let status = await (async () => {\r\n        console.log(\"hhhh\");\r\n        console.log(inputToken0);\r\n        console.log(inputToken1);\r\n\r\n        // let router = await getRouterContract(library, account);\r\n        const {\r\n            symbol: inToken0Symbol,\r\n            address: inToken0Address,\r\n            decimal: inToken0Decimal\r\n        } = inputToken0;\r\n        const {\r\n            symbol: inToken1Symbol,\r\n            address: inToken1Address,\r\n            decimal: inToken1Decimal\r\n        } = inputToken1;\r\n\r\n        let token0IsETH = inToken0Symbol === \"ETH\";\r\n        let token1IsETH = inToken1Symbol === \"ETH\";\r\n\r\n        if (!inputToken0.symbol || !inputToken1.symbol)\r\n            return new ACYSwapErrorStatus(\"One or more token input is missing\");\r\n\r\n        console.log(\"------------------ RECEIVED TOKEN ------------------\");\r\n        console.log(\"token0\");\r\n        console.log(inputToken0);\r\n        console.log(\"token1\");\r\n        console.log(inputToken1);\r\n\r\n        if (token0IsETH && token1IsETH)\r\n            return new ACYSwapErrorStatus(\"Doesn't support ETH to ETH\");\r\n\r\n        if (\r\n            (token0IsETH && inToken1Symbol === \"WETH\") ||\r\n            (inToken0Symbol === \"WETH\" && token1IsETH)\r\n        ) {\r\n            return new ACYSwapErrorStatus(\"Invalid pair WETH/ETH\");\r\n        }\r\n        // ETH <-> Non-WETH ERC20     OR     Non-WETH ERC20 <-> Non-WETH ERC20\r\n        else {\r\n            console.log(\"ATTEMPT TO APPROVE\")\r\n            console.log(\"------------------ CONSTRUCT TOKEN ------------------\");\r\n\r\n            // use WETH for ETHER to work with Uniswap V2 SDK\r\n            const token0 = token0IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken0Address, inToken0Decimal, inToken0Symbol);\r\n            const token1 = token1IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, inToken1Address, inToken1Decimal, inToken1Symbol);\r\n\r\n            if (token0.equals(token1)) return new ACYSwapErrorStatus(\"Equal tokens!\");\r\n\r\n            // get pair using our own provider\r\n            console.log(\"------------------ CONSTRUCT PAIR ------------------\");\r\n            console.log(\"FETCH\");\r\n            // if an error occurs, because pair doesn't exists\r\n            const pair = await Fetcher.fetchPairData(token0, token1, library).catch(\r\n                (e) => {\r\n                    console.log(e);\r\n                    return new ACYSwapErrorStatus(\r\n                        `${token0.symbol} - ${token1.symbol} pool does not exist.`\r\n                    );\r\n                }\r\n            );\r\n            console.log(pair);\r\n            if (pair instanceof ACYSwapErrorStatus) {\r\n                setRemoveStatus(pair.getErrorText());\r\n                return pair;\r\n            }\r\n\r\n            let pairContract = await getPairContract(\r\n                pair.liquidityToken.address,\r\n                library,\r\n                account\r\n            );\r\n\r\n            console.log(pairContract);\r\n\r\n            // try to gather a signature for permission\r\n\r\n\r\n            let totalPoolTokens = await getTokenTotalSupply(\r\n                pair.liquidityToken,\r\n                library,\r\n                account\r\n            );\r\n\r\n            let userPoolBalance = await getUserTokenBalanceRaw(\r\n                pair.liquidityToken,\r\n                account,\r\n                library\r\n            );\r\n\r\n            userPoolBalance = new TokenAmount(pair.liquidityToken, userPoolBalance);\r\n\r\n            console.log(\"getLiquidityValue\");\r\n            console.log(pair.token0);\r\n\r\n            let shang = percent * 100;\r\n            let percentToRemove = new Percent(\r\n                shang.toString(),\r\n                \"10000\"\r\n            );\r\n            let liquidityAmount = new TokenAmount(\r\n                userPoolBalance.token,\r\n                percentToRemove.multiply(userPoolBalance.raw).quotient\r\n            );\r\n\r\n\r\n\r\n            console.log(userPoolBalance.toExact());\r\n            console.log(percentToRemove.toSignificant(2));\r\n            console.log(liquidityAmount.raw);\r\n\r\n            //\r\n            //\r\n            //\r\n            // console.log( liquidityAmount.raw.toString());\r\n            // let state=await approve(liquidityAmount.token.address, liquidityAmount.raw.toString(), library, account);\r\n            // if(state==true){\r\n            //     setButtonStatus(true);\r\n            // }\r\n            // return \"just approve\";\r\n\r\n            const nonce = await pairContract.nonces(account);\r\n\r\n            const EIP712Domain = [\r\n                {name: \"name\", type: \"string\"},\r\n                {name: \"version\", type: \"string\"},\r\n                {name: \"chainId\", type: \"uint256\"},\r\n                {name: \"verifyingContract\", type: \"address\"},\r\n            ];\r\n            const domain = {\r\n                name: \"Uniswap V2\",\r\n                version: \"1\",\r\n                chainId: chainId,\r\n                verifyingContract: pair.liquidityToken.address,\r\n            };\r\n\r\n            console.log(\"Router address\");\r\n            console.log(ROUTER_ADDRESS);\r\n\r\n            console.log(\"pair.liquidityToken.address\");\r\n            console.log(pair.liquidityToken.address);\r\n\r\n            const Permit = [\r\n                {name: \"owner\", type: \"address\"},\r\n                {name: \"spender\", type: \"address\"},\r\n                {name: \"value\", type: \"uint256\"},\r\n                {name: \"nonce\", type: \"uint256\"},\r\n                {name: \"deadline\", type: \"uint256\"},\r\n            ];\r\n\r\n            var now=new Date();\r\n\r\n            const deadlineTime=Math.floor(now.getTime()/1000)+60*20;\r\n\r\n            console.log(\"deadlineTime\");\r\n            console.log(deadlineTime);\r\n            console.log(deadlineTime);\r\n            console.log(deadlineTime);\r\n\r\n            let message = {\r\n                owner: account,\r\n                spender: ROUTER_ADDRESS,\r\n                value: liquidityAmount.raw.toString(),\r\n                nonce: nonce.toHexString(),\r\n                deadline:deadlineTime\r\n                //1630718219////Math.floor(new Date().getTime() / 1000) + 60,\r\n            };\r\n\r\n            console.log(\"message\")\r\n            console.log(message)\r\n\r\n            const data = JSON.stringify({\r\n                types: {\r\n                    EIP712Domain,\r\n                    Permit,\r\n                },\r\n                domain,\r\n                primaryType: \"Permit\",\r\n                message,\r\n            });\r\n\r\n            library\r\n                .send(\"eth_signTypedData_v4\", [account, data])\r\n                .then(splitSignature)\r\n                .then(signature => {\r\n\r\n                    console.log(\"sign!!!!!\");\r\n                    console.log(\"signature\");\r\n                    console.log(signature);\r\n                    setSignatureData({\r\n                        v: signature.v,\r\n                        r: signature.r,\r\n                        s: signature.s,\r\n                        deadline: deadlineTime//1630718219//Math.floor(new Date().getTime() / 1000) + 60//1630717588 //Math.floor(new Date().getTime() / 1000) + 60,\r\n                    });\r\n\r\n                   //  console.log(deadlineTime);\r\n                   // console.log(Math.floor(new Date().getTime() / 1000) + 60);\r\n                   // console.log(Math.floor(new Date().getTime() / 1000) + 60);\r\n                   // console.log(Math.floor(new Date().getTime() / 1000) + 60);\r\n                   // console.log(Math.floor(new Date().getTime() / 1000) + 60);\r\n                   // console.log(Math.floor(new Date().getTime() / 1000) + 60);\r\n                   // console.log(Math.floor(new Date().getTime() / 1000) + 60);\r\n\r\n\r\n                    setNeedApprove(false);\r\n                    setButtonContent(\"remove liquidity\");\r\n                    setButtonStatus(true);\r\n\r\n                })\r\n                .catch(error => {\r\n                    // for all errors other than 4001 (EIP-1193 user rejected request), fall back to manual approve\r\n                    if (error.code != 4001) {\r\n                        // approveCallback();\r\n                        // const [approval, approveCallback] = useApproveCallback(\r\n                        //     liquidityAmount,\r\n                        //     ROUTER_ADDRESS,\r\n                        //     library,\r\n                        //     account);\r\n                        // export async function approve(tokenAddress, requiredAmount, library, account) {\r\n                        alert(\"error code !=4001!\");\r\n                        let state = approve(liquidityAmount.token.address, liquidityAmount.raw.toString(), library, account);\r\n                        if (state == true) {\r\n                            setNeedApprove(false);\r\n                            setButtonContent(\"remove liquidity\");\r\n                            setButtonStatus(true);\r\n                            return \"approve success\";\r\n                        }\r\n                    } else {\r\n                        alert(\"error code 4001!\");\r\n                        console.log(\"error code 4001!\");\r\n                        return new ACYSwapErrorStatus(\" 4001 (EIP-1193 user rejected request), fall back to manual approve\");\r\n                    }\r\n                });\r\n\r\n            //\r\n            // let allowance = await getAllowance(\r\n            //     liquidityAmount.token.address,\r\n            //     account, // owner\r\n            //     ROUTER_ADDRESS, //spender\r\n            //     library, // provider\r\n            //     account // active account\r\n            // );\r\n            //\r\n            // console.log(`ALLOWANCE FOR TOKEN ${liquidityAmount.token.address}`);\r\n            // console.log(allowance);\r\n            return \"end\";\r\n\r\n\r\n        }\r\n    })();\r\n    if (status instanceof ACYSwapErrorStatus) {\r\n        setRemoveStatus(status.getErrorText());\r\n    } else {\r\n\r\n        setRemoveStatus(\"just click right button\");\r\n        console.log(status);\r\n        console.log(\"it seems ok\");\r\n    }\r\n}\r\n\r\nexport async function removeLiquidity(\r\n    inputToken0,\r\n    inputToken1,\r\n    index,\r\n    percent,\r\n    amount,\r\n    allowedSlippage = INITIAL_ALLOWED_SLIPPAGE,\r\n    chainId,\r\n    library,\r\n    account,\r\n    setToken0Amount,\r\n    setToken1Amount,\r\n    signatureData,\r\n    setNeedApprove,\r\n    setButtonStatus,\r\n    setButtonContent,\r\n    setRemoveStatus\r\n) {\r\n    /**\r\n     1. Check parameter, token amount valid?, token exists? token{0/1}IsETH\r\n     2. Create 2 Uniswap Token\r\n     3. Create Uniswap Pair, get liquidity token\r\n     4. Parse amount into TokenAmount or CurrencyAmount\r\n     5. Check liquidity balance and get pair contract\r\n     7. Try to sign with pair contract from (4), requires nonce, library, setSignatureData\r\n     8. Manual approve fallback\r\n     9. Check approval, then check ETH, use normal version\r\n     10. Signature exists, check ETH, use permit version\r\n     11. estimate Gas for all methods\r\n     12. index of Successful estimation by checking if gas estimate is BigNumber\r\n     13. call method\r\n     **/\r\n    let status = await (async () => {\r\n        let router = getRouterContract(library, account);\r\n       let  {\r\n            address: token0Address,\r\n            symbol: token0Symbol,\r\n            decimal: token0Decimal,\r\n        } = inputToken0;\r\n        let{\r\n            address: token1Address,\r\n            symbol: token1Symbol,\r\n            decimal: token1Decimal,\r\n        } = inputToken1;\r\n\r\n        console.log(token0Address);\r\n        token0Address=getAddress(token0Address);\r\n        console.log(token0Address);\r\n\r\n        console.log(token1Address);\r\n        token1Address=getAddress(token1Address);\r\n        console.log(token1Address);\r\n\r\n        let token0IsETH = token0Symbol === \"ETH\";\r\n        let token1IsETH = token1Symbol === \"ETH\";\r\n\r\n        if (!inputToken0.symbol || !inputToken1.symbol)\r\n            return new ACYSwapErrorStatus(\"One or more token input is missing\");\r\n\r\n\r\n            if (index==0 && percent == \"0\")\r\n            return new ACYSwapErrorStatus(\"percent is 0\");\r\n        if (index==1 && amount == \"0\")\r\n            return new ACYSwapErrorStatus(\"amount is 0\");\r\n        if(index==0 && percent == \"\")\r\n            return new ACYSwapErrorStatus(\"percent is \\\"\\\"\");\r\n        if(index==1 && amount==\"\")\r\n            return new ACYSwapErrorStatus(\"amount is \\\"\\\"\");\r\n        if (index==0 && (isNaN(parseFloat(percent))))\r\n            return new ACYSwapErrorStatus(\"percent is NaN\");\r\n        if (index==1 && (isNaN(parseFloat(amount))))\r\n            return new ACYSwapErrorStatus(\"amount is NaN\");\r\n\r\n        console.log(\"------------------ RECEIVED TOKEN ------------------\");\r\n        console.log(\"token0\");\r\n        console.log(inputToken0);\r\n        console.log(\"token1\");\r\n        console.log(inputToken1);\r\n\r\n        if (token0IsETH && token1IsETH)\r\n            return new ACYSwapErrorStatus(\"Doesn't support ETH to ETH\");\r\n\r\n        if (\r\n            (token0IsETH && token1Symbol === \"WETH\") ||\r\n            (token0Symbol === \"WETH\" && token1IsETH)\r\n        ) {\r\n            return new ACYSwapErrorStatus(\"Invalid pair WETH/ETH\");\r\n        }\r\n        // ETH <-> Non-WETH ERC20     OR     Non-WETH ERC20 <-> Non-WETH ERC20\r\n        else {\r\n            console.log(\"------------------ CONSTRUCT TOKEN ------------------\");\r\n            // use WETH for ETHER to work with Uniswap V2 SDK\r\n            const token0 = token0IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, token0Address, token0Decimal, token0Symbol);\r\n            const token1 = token1IsETH\r\n                ? WETH[chainId]\r\n                : new Token(chainId, token1Address, token1Decimal, token1Symbol);\r\n\r\n\r\n            if (token0.equals(token1)) return new ACYSwapErrorStatus(\"Equal tokens!\");\r\n\r\n\r\n            // get pair using our own provider\r\n            console.log(\"------------------ CONSTRUCT PAIR ------------------\");\r\n            console.log(\"FETCH\");\r\n            // if an error occurs, because pair doesn't exists\r\n            const pair = await Fetcher.fetchPairData(token0, token1, library).catch(\r\n                (e) => {\r\n                    console.log(e);\r\n                    return new ACYSwapErrorStatus(\r\n                        `${token0.symbol} - ${token1.symbol} pool does not exist.`\r\n                    );\r\n                }\r\n            );\r\n            console.log(pair);\r\n            if (pair instanceof ACYSwapErrorStatus) {\r\n                setRemoveStatus(pair.getErrorText());\r\n                return pair;\r\n            }\r\n\r\n            let pairContract = getPairContract(\r\n                pair.liquidityToken.address,\r\n                library,\r\n                account\r\n            );\r\n\r\n            console.log(pairContract);\r\n\r\n            let totalPoolTokens = await getTokenTotalSupply(\r\n                pair.liquidityToken,\r\n                library,\r\n                account\r\n            );\r\n\r\n            let userPoolBalance = await getUserTokenBalanceRaw(\r\n                pair.liquidityToken,\r\n                account,\r\n                library\r\n            );\r\n\r\n            userPoolBalance = new TokenAmount(pair.liquidityToken, userPoolBalance);\r\n\r\n            let token0Deposited = pair.getLiquidityValue(\r\n                pair.token0,\r\n                totalPoolTokens,\r\n                userPoolBalance,\r\n                false\r\n            );\r\n            let token1Deposited = pair.getLiquidityValue(\r\n                pair.token1,\r\n                totalPoolTokens,\r\n                userPoolBalance,\r\n                false\r\n            );\r\n            // 这是一个tokenAMount\r\n            console.log(token0Deposited);\r\n            console.log(token1Deposited);\r\n\r\n\r\n            let shang = percent * 100;\r\n            let percentToRemove = new Percent(\r\n                shang.toString(),\r\n                \"10000\"\r\n            );\r\n\r\n            let liquidityAmount = new TokenAmount(\r\n                userPoolBalance.token,\r\n                percentToRemove.multiply(userPoolBalance.raw).quotient\r\n            );\r\n\r\n            let token0TokenAmount = new TokenAmount(\r\n                token0,\r\n                percentToRemove.multiply(token0Deposited.raw).quotient\r\n            );\r\n\r\n            console.log(\"this is ok?\");\r\n            console.log(percentToRemove.multiply(token0Deposited.raw).quotient);\r\n            console.log(token0TokenAmount.raw);\r\n            console.log(token0TokenAmount.toExact());\r\n            console.log(token0TokenAmount);\r\n\r\n            let token1TokenAmount = new TokenAmount(\r\n                token1,\r\n                percentToRemove.multiply(token1Deposited.raw).quotient\r\n            );\r\n\r\n            let parsedToken0Amount;\r\n            let parsedToken1Amount;\r\n\r\n\r\n           // 先假设都不是ETH\r\n            parsedToken0Amount =\r\n                token0 === ETHER\r\n                    ? CurrencyAmount.ether(token0TokenAmount.raw)\r\n                    : token0TokenAmount;\r\n            parsedToken1Amount =\r\n                token1 === ETHER\r\n                    ? CurrencyAmount.ether(token1TokenAmount.raw)\r\n                    : token1TokenAmount;\r\n\r\n            // parsedToken0Amount = token0TokenAmount;\r\n            // parsedToken1Amount = token1TokenAmount;\r\n\r\n            // setToken0Amount(parsedToken0Amount.toExact());\r\n            // setToken1Amount(parsedToken1Amount.toExact());\r\n\r\n\r\n            let liquidityApproval = await checkTokenIsApproved(\r\n                liquidityAmount.token.address,\r\n                liquidityAmount.raw.toString(),\r\n                library,\r\n                account\r\n            );\r\n\r\n            if (!liquidityApproval && signatureData === null) {\r\n                console.log(\"liquidityApproval is not ok\");\r\n                return new ACYSwapErrorStatus(\r\n                    'need approve for liquidityApproval'\r\n                );\r\n            }\r\n\r\n            let oneCurrencyIsETH = token0IsETH || token1IsETH\r\n            let estimate\r\n            let methodNames\r\n            let args\r\n            let value\r\n\r\n            console.log(\"allowedSlippage\");\r\n            console.log(allowedSlippage);\r\n\r\n\r\n            const amountsMin = {\r\n                [\"CURRENCY_A\"]: calculateSlippageAmount(parsedToken0Amount, allowedSlippage)[0].toString(),\r\n                [\"CURRENCY_B\"]: calculateSlippageAmount(parsedToken1Amount, allowedSlippage)[0].toString()\r\n            }\r\n\r\n            if (liquidityApproval) {\r\n                if (oneCurrencyIsETH) {\r\n                    console.log(\"111\");\r\n                    methodNames = ['removeLiquidityETH', 'removeLiquidityETHSupportingFeeOnTransferTokens']\r\n                    args = [\r\n                        token1IsETH ? token0Address : token1Address,\r\n                        liquidityAmount.raw.toString(),\r\n                        amountsMin[token0IsETH ? \"CURRENCY_A\" : \"CURRENCY_B\"].toString(),\r\n                        amountsMin[token1IsETH ? \"CURRENCY_B\" : \"CURRENCY_A\"].toString(),\r\n                        // amountsMin[currencyBIsETH ? Field.CURRENCY_A : Field.CURRENCY_B].toString(),\r\n                        // amountsMin[currencyBIsETH ? Field.CURRENCY_B : Field.CURRENCY_A].toString(),\r\n                        account,\r\n                        `0x${(Math.floor(new Date().getTime() / 1000) + 60).toString(16)}`\r\n                    ]\r\n                } else {\r\n                    console.log(\"222\");\r\n                    methodNames = ['removeLiquidity']\r\n                    args = [\r\n                        token0Address,\r\n                        token1Address,\r\n                        liquidityAmount.raw.toString(),\r\n                        amountsMin[\"CURRENCY_A\"].toString(),\r\n                        amountsMin[\"CURRENCY_B\"].toString(),\r\n                        account,\r\n                        `0x${(Math.floor(new Date().getTime() / 1000) + 60).toString(16)}`\r\n                    ]\r\n                }\r\n\r\n            } else if (signatureData !== null) {\r\n                if (oneCurrencyIsETH) {\r\n                    console.log(\"333\");\r\n                    methodNames = ['removeLiquidityETHWithPermit', 'removeLiquidityETHWithPermitSupportingFeeOnTransferTokens']\r\n                    args = [\r\n                        token1IsETH ? token0Address : token1Address,\r\n                        liquidityAmount.raw.toString(),\r\n                        amountsMin[token1IsETH ? \"CURRENCY_A\" : \"CURRENCY_B\"].toString(),\r\n                        amountsMin[token1IsETH ? \"CURRENCY_B\" : \"CURRENCY_A\"].toString(),\r\n                        account,\r\n                        signatureData.deadline,\r\n                        false,\r\n                        signatureData.v,\r\n                        signatureData.r,\r\n                        signatureData.s\r\n                    ]\r\n                } else {\r\n                    console.log(\"444\");\r\n                    methodNames = ['removeLiquidityWithPermit']\r\n                    args = [\r\n                        token0Address,\r\n                        token1Address,\r\n                        liquidityAmount.raw.toString(),\r\n                        amountsMin[\"CURRENCY_A\"].toString(),\r\n                        amountsMin[\"CURRENCY_B\"].toString(),\r\n                        account,\r\n                        signatureData.deadline,\r\n                        false,\r\n                        signatureData.v,\r\n                        signatureData.r,\r\n                        signatureData.s\r\n                    ]\r\n                }\r\n\r\n            } else {\r\n                return new ACYSwapErrorStatus(\r\n                    \"Attempting to confirm without approval or a signature. Please contact support.\"\r\n                );\r\n            }\r\n            let safeGasEstimates;\r\n\r\n                let result;\r\n\r\n                safeGasEstimates= await Promise.all(\r\n                    result= methodNames.map(methodName =>\r\n                        router.estimateGas[methodName](...args)\r\n                            .then(calculateGasMargin)\r\n                            .catch(error => {\r\n                                console.error(`estimateGas failed`, methodName, args, error)\r\n                                return new ACYSwapErrorStatus(console.error(`estimateGas failed`, methodName, args, error))\r\n                            })\r\n                    )\r\n                )\r\n\r\n            console.log(\"i want to see\");\r\n            console.log(result);\r\n                console.log(safeGasEstimates);\r\n\r\n            for(let item in safeGasEstimates){\r\n                if(item instanceof ACYSwapErrorStatus){\r\n                    console.log(\"safeGasEstimates is wrong\");\r\n                    return item;\r\n                }\r\n            }\r\n\r\n                //return new ACYSwapErrorStatus(\"safeGasEstimates is wrong\");\r\n\r\n            const indexOfSuccessfulEstimation = safeGasEstimates.findIndex(safeGasEstimate =>\r\n                BigNumber.isBigNumber(safeGasEstimate)\r\n            )\r\n\r\n\r\n            if (indexOfSuccessfulEstimation === -1) {\r\n                console.error(\"This transaction would fail. Please contact support.\");\r\n                return new ACYSwapErrorStatus(\"safeGasEstimates is wrong\");\r\n\r\n            } else {\r\n                const methodName = methodNames[indexOfSuccessfulEstimation]\r\n                const safeGasEstimate = safeGasEstimates[indexOfSuccessfulEstimation]\r\n\r\n                let result = await router[methodName](...args, {\r\n                    gasLimit: safeGasEstimate\r\n                }).then((response)=>{\r\n                    console.log(response);\r\n                    return response;\r\n\r\n                }).catch((e)=>{\r\n                    return new ACYSwapErrorStatus(\"error happen\");\r\n                });\r\n\r\n                if(result instanceof  ACYSwapErrorStatus){\r\n                    console.log(\"result is error\");\r\n\r\n                }\r\n                return result;\r\n\r\n            }\r\n        }\r\n    })();\r\n    if (status instanceof ACYSwapErrorStatus) {\r\n        setRemoveStatus(status.getErrorText());\r\n    } else {\r\n        console.log(status);\r\n\r\n        let url = \"https://rinkeby.etherscan.io/tx/\" + status.hash;\r\n        setRemoveStatus(<a href={url} target={\"_blank\"}>view it on etherscan</a>);\r\n    }\r\n}\r\n\r\nconst RemoveLiquidityComponent = () => {\r\n    let [token0, setToken0] = useState(null);\r\n    let [token1, setToken1] = useState(null);\r\n    let [token0Amount, setToken0Amount] = useState(\"0\");\r\n    let [token1Amount, setToken1Amount] = useState(\"0\");\r\n    // 仓位信息，确定两种代币之后就可以确定了\r\n    let [position, setPosition] = useState();\r\n    // uni-v2 的余额\r\n    let [balance, setBalance] = useState(\"0\");\r\n    let [balanceShow, setBalanceShow] = useState(false);\r\n    //index==0 表示百分比，index==1 表示数额\r\n    let [index, setIndex] = useState(0);\r\n    // 代币的百分比\r\n    let [percent, setPercent] = useState(0);\r\n    // 代币的数额\r\n    let [amount, setAmount] = useState(\"0\");\r\n    let [slippageTolerance, setSlippageTolerance] = useState(INITIAL_ALLOWED_SLIPPAGE / 100);\r\n    let [breakdown, setBreakdown] = useState();\r\n    let [needApprove, setNeedApprove] = useState(false);\r\n    let [buttonStatus, setButtonStatus] = useState();\r\n    let [buttonContent, setButtonContent] = useState();\r\n    // 点击按钮之后的返回信息\r\n    let [removeStatus, setRemoveStatus] = useState();\r\n    let [signatureData, setSignatureData] = useState(null);\r\n    const slippageTolerancePlaceholder = \"please input a number from 1.00 to 100.00\";\r\n\r\n\r\n    const {account, chainId, library, activate} = useWeb3React();\r\n    const injected = new InjectedConnector({\r\n        supportedChainIds: [1, 3, 4, 5, 42, 80001],\r\n    });\r\n\r\n\r\n    useEffect(() => {\r\n        //  activate(injected);\r\n    }, []);\r\n\r\n    // useEffect(() => {\r\n    //     async function getUserRemoveLiquidityPositions() {\r\n    //         if (account == undefined) {\r\n    //             // alert(\"please connect to your account\");\r\n    //             return;\r\n    //         }\r\n    //         if (!token0 || !token1) {\r\n    //             // alert(\"you need to choose both of the tokens\");\r\n    //             return;\r\n    //         }\r\n    //         await getPositionAndBalance(\r\n    //             token0,\r\n    //             token1,\r\n    //             chainId,\r\n    //             account,\r\n    //             library,\r\n    //             setBalance,\r\n    //             setBalanceShow,\r\n    //             setPosition\r\n    //         );\r\n    //     }\r\n    //\r\n    //     getUserRemoveLiquidityPositions();\r\n    // }, [token0, token1, chainId, account, library]);\r\n\r\n\r\n    let inputChange = useCallback(async () => {\r\n        if(!token0||!token1) return;\r\n\r\n        //  alert(percent+\" \"+amount+\" \"+needApprove);\r\n        await getEstimated(\r\n            {\r\n                ...token0\r\n            },\r\n            {\r\n                ...token1\r\n            },// 这里是不包含amount信息的\r\n            token0Amount,\r\n            token1Amount,\r\n            index,\r\n            percent,\r\n            amount,\r\n            chainId,\r\n            library,\r\n            account,\r\n            setToken0Amount,\r\n            setToken1Amount,\r\n            setBalance,\r\n            setBalanceShow,\r\n            setPercent,\r\n            setAmount,\r\n            setBreakdown,\r\n            setNeedApprove,\r\n            setButtonStatus,\r\n            setButtonContent,\r\n            setRemoveStatus);\r\n    }, [token0, token1, index, percent, amount,slippageTolerance,chainId, library, account]);\r\n\r\n\r\n    useEffect(() => {  \r\n        inputChange();\r\n    }, [token0, token1, index, percent, amount,slippageTolerance,chainId, library, account]);\r\n\r\n    useEffect(()=>{\r\n        if (account == undefined) {\r\n            setNeedApprove(false);\r\n            setButtonStatus(true);\r\n            setButtonContent(\"Connect to Wallet\");\r\n        } else {\r\n            setNeedApprove(false);\r\n            setButtonStatus(false);\r\n            setButtonContent(\"choose tokens and amount\");\r\n        }\r\n    },[account]);\r\n\r\n    return (\r\n        <div>\r\n            <h1>Remove liquidity</h1>\r\n            <Form>\r\n                <Form.Group className=\"mb-3\" controlId=\"token0\">\r\n                    <Dropdown>\r\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\r\n                            {(token0 && token0.symbol) || \"In token\"}\r\n                        </Dropdown.Toggle>\r\n                        <Dropdown.Menu>\r\n                            {supportedTokens.map((token, index) => (\r\n                                <Dropdown.Item\r\n                                    key={index}\r\n                                    onClick={async () => {\r\n                                        setToken0(token);\r\n                                    }}\r\n                                >\r\n                                    {token.symbol}\r\n                                </Dropdown.Item>\r\n                            ))}\r\n                        </Dropdown.Menu>\r\n                    </Dropdown>\r\n                    <Form.Control value={token0Amount}/>\r\n                    {/*<small>Balance: {token0Balance}</small>*/}\r\n                </Form.Group>\r\n                <Form.Group className=\"mb-3\" controlId=\"token1\">\r\n                    <Dropdown>\r\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\r\n                            {(token1 && token1.symbol) || \"Out token\"}\r\n                        </Dropdown.Toggle>\r\n\r\n                        <Dropdown.Menu>\r\n                            {supportedTokens.map((token, index) => (\r\n                                <Dropdown.Item\r\n                                    key={index}\r\n                                    onClick={async () => {\r\n                                        setToken1(token);\r\n                                    }}\r\n                                >\r\n                                    {token.symbol}\r\n                                </Dropdown.Item>\r\n                            ))}\r\n                        </Dropdown.Menu>\r\n                    </Dropdown>\r\n                    <Form.Control value={token1Amount}/>\r\n                    {/*<small>Balance: {token1Balance}</small>*/}\r\n                </Form.Group>\r\n                <Form.Group className=\"mb-3\" controlId=\"percent\">\r\n                    <Dropdown>\r\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\r\n                            percent\r\n                        </Dropdown.Toggle>\r\n                    </Dropdown>\r\n\r\n                    <Form.Control value={percent}\r\n\r\n                                  onChange={(e) => {\r\n                                      setPercent(e.target.value);\r\n                                      setIndex(0);\r\n                                  }}\r\n                    />\r\n                </Form.Group>\r\n                <Form.Group className=\"mb-3\" controlId=\"amount\">\r\n                    <Dropdown>\r\n                        <Dropdown.Toggle variant=\"success\" id=\"dropdown-basic\">\r\n                            amount\r\n                        </Dropdown.Toggle>\r\n                    </Dropdown>\r\n                    <Form.Control value={amount}\r\n                                  onChange={(e) => {\r\n                                      setAmount(e.target.value);\r\n                                      setIndex(1);\r\n\r\n                                  }}\r\n                    />\r\n                </Form.Group>\r\n\r\n                <div>\r\n                    {<mark>balance</mark>}\r\n                    {balanceShow && <p>{balance}</p>}\r\n                </div>\r\n\r\n                {/*<Alert variant=\"info\">*/}\r\n                {/*    {<mark>position</mark>}*/}\r\n                {/*    {position && position.map((info) => <p>{info}</p>)}*/}\r\n                {/*</Alert>*/}\r\n\r\n                <InputGroup size=\"sm\" className=\"mb-3\">\r\n                    <InputGroup.Text id=\"inputGroup-sizing-sm\">Slippage tolerance </InputGroup.Text>\r\n                    <FormControl\r\n                        aria-label=\"Small\"\r\n                        aria-describedby=\"inputGroup-sizing-sm\"\r\n                        placeholder={slippageTolerancePlaceholder}\r\n                        onChange={(e => {\r\n                            setSlippageTolerance(e.target.value);\r\n                        })}\r\n\r\n                    />\r\n                    <InputGroup.Text>%</InputGroup.Text>\r\n                </InputGroup>\r\n                <Alert variant=\"danger\">\r\n                    the Slippage Tolerance you choose is [ {slippageTolerance}% ]\r\n                </Alert>\r\n\r\n                <Alert variant=\"info\">\r\n                    {<mark>breakdown</mark>}\r\n                    {breakdown && breakdown.map((info) => <p>{info}</p>)}\r\n                </Alert>\r\n\r\n\r\n                {/* APPROVE BUTTONS */}\r\n                <Button variant=\"warning\" onClick={async () => {\r\n                    await signOrApprove(\r\n                        {...token0,},\r\n                        {...token1,},\r\n                        index,\r\n                        percent,\r\n                        amount,\r\n                        slippageTolerance * 100,\r\n                        chainId,\r\n                        library,\r\n                        account,\r\n                        setNeedApprove,\r\n                        setButtonStatus,\r\n                        setButtonContent,\r\n                        setRemoveStatus,\r\n                        setSignatureData\r\n                    );\r\n                }}\r\n                        disabled={!needApprove}\r\n                >Approve</Button>\r\n\r\n                {' '}\r\n\r\n                <Button\r\n                    variant=\"success\"\r\n                    onClick={async () => {\r\n                        if(account==undefined){\r\n                            activate(injected);\r\n                            \r\n                        }else{\r\n\r\n                     \r\n\r\n                        await removeLiquidity(\r\n                            {...token0,},\r\n                            {...token1,},\r\n                            index,\r\n                            percent,\r\n                            amount,\r\n                            slippageTolerance * 100,\r\n                            chainId,\r\n                            library,\r\n                            account,\r\n                            setToken0Amount,\r\n                            setToken1Amount,\r\n                            signatureData,\r\n                            setNeedApprove,\r\n                            setButtonStatus,\r\n                            setButtonContent,\r\n                            setRemoveStatus\r\n                        );\r\n                    }\r\n\r\n                    }}\r\n                    disabled={!buttonStatus}\r\n                >\r\n                    {buttonContent}\r\n                </Button>\r\n                <Alert variant=\"info\">\r\n                    {removeStatus}\r\n                </Alert>\r\n\r\n            </Form>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default RemoveLiquidityComponent;\r\n","D:\\GitHub\\acy-dex-swap\\src\\utils\\index.js",["122","123","124","125","126","127","128","129"],"import { abi as IUniswapV2Router02ABI } from \"../abis/IUniswapV2Router02.json\";\r\nimport { abi as IUniswapV2PairABI } from \"@uniswap/v2-core/build/IUniswapV2Pair.json\";\r\nimport ERC20ABI from \"../abis/ERC20.json\";\r\nimport { getAddress } from \"@ethersproject/address\";\r\nimport { Contract } from \"@ethersproject/contracts\";\r\nimport { AddressZero } from \"@ethersproject/constants\";\r\nimport { BigNumber } from \"@ethersproject/bignumber\";\r\nimport { parseUnits, formatUnits } from \"@ethersproject/units\";\r\nimport {\r\n  JSBI,\r\n  Token,\r\n  TokenAmount,\r\n  TradeType,\r\n  Route,\r\n  Trade,\r\n  Fetcher,\r\n  Percent,\r\n  WETH,\r\n  ETHER,\r\n  CurrencyAmount,\r\n  InsufficientReservesError,\r\n} from \"@uniswap/sdk\";\r\nimport { MaxUint256 } from \"@ethersproject/constants\";\r\n\r\nexport const INITIAL_ALLOWED_SLIPPAGE = 50; //bips\r\n\r\nexport const ROUTER_ADDRESS = \"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\";\r\n// export const ROUTER_ADDRESS = \"0xF3726d6acfeda3E73a6F2328b948834f3Af39A2B\";\r\n\r\nexport const supportedTokens = [\r\n  {\r\n    symbol: \"USDC\",\r\n    address: \"0x4DBCdF9B62e891a7cec5A2568C3F4FAF9E8Abe2b\",\r\n    decimal: 6,\r\n  },\r\n  {\r\n    symbol: \"ETH\",\r\n    address: \"0xc778417E063141139Fce010982780140Aa0cD5Ab\",\r\n    decimal: 18,\r\n  },\r\n  {\r\n    symbol: \"TEST\",\r\n    address: \"0xAEd3ed6cF66E1CB13ab8DC312a0dC91bc0936721\",\r\n    decimal: 18,\r\n  },\r\n];\r\n\r\nexport function isAddress(value) {\r\n  try {\r\n    return getAddress(value);\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n// account is not optional\r\nexport function getSigner(library, account) {\r\n  return library.getSigner(account).connectUnchecked();\r\n}\r\n\r\n// account is optional\r\nexport function getProviderOrSigner(library, account) {\r\n  return account ? getSigner(library, account) : library;\r\n}\r\n\r\n// account is optional\r\nexport function getContract(address, ABI, library, account) {\r\n  if (!isAddress(address) || address === AddressZero) {\r\n    throw Error(`Invalid 'address' parameter '${address}'.`);\r\n  }\r\n\r\n  return new Contract(address, ABI, getProviderOrSigner(library, account));\r\n}\r\n\r\nexport function getRouterContract(library, account) {\r\n  return getContract(ROUTER_ADDRESS, IUniswapV2Router02ABI, library, account);\r\n}\r\n\r\nexport function getPairContract(pairAddress, library, account) {\r\n  return getContract(pairAddress, IUniswapV2PairABI, library, account);\r\n}\r\n\r\n// return gas with 10% added margin in BigNumber\r\nexport function calculateGasMargin(value) {\r\n  console.log(\"just calculateGasMargin\");\r\n  return value\r\n    .mul(BigNumber.from(10000).add(BigNumber.from(1000)))\r\n    .div(BigNumber.from(10000));\r\n}\r\n\r\n// check if hex string is zero\r\nexport function isZero(hexNumberString) {\r\n  return /^0x0*$/.test(hexNumberString);\r\n}\r\n\r\n// return token allowance in BigNumber\r\nexport async function getAllowance(\r\n  tokenAddress,\r\n  owner,\r\n  spender,\r\n  library,\r\n  account\r\n) {\r\n  let tokenContract = getContract(tokenAddress, ERC20ABI, library, account);\r\n  let allowance = await tokenContract.allowance(owner, spender);\r\n  console.log(allowance);\r\n  return allowance;\r\n}\r\n\r\n// a custom error class for custom error text and handling\r\nexport class ACYSwapErrorStatus {\r\n  getErrorText() {\r\n    return this.errorText;\r\n  }\r\n  constructor(errorText) {\r\n    this.errorText = errorText;\r\n  }\r\n}\r\n\r\n// taken from Uniswap, used for price impact and realized liquid provider fee\r\nexport function computeTradePriceBreakdown(trade) {\r\n  const BASE_FEE = new Percent(JSBI.BigInt(30), JSBI.BigInt(10000));\r\n  const ONE_HUNDRED_PERCENT = new Percent(\r\n    JSBI.BigInt(10000),\r\n    JSBI.BigInt(10000)\r\n  );\r\n  const INPUT_FRACTION_AFTER_FEE = ONE_HUNDRED_PERCENT.subtract(BASE_FEE);\r\n\r\n  // for each hop in our trade, take away the x*y=k price impact from 0.3% fees\r\n  // e.g. for 3 tokens/2 hops: 1 - ((1 - .03) * (1-.03))\r\n  const realizedLPFee = !trade\r\n    ? undefined\r\n    : ONE_HUNDRED_PERCENT.subtract(\r\n        trade.route.pairs.reduce(\r\n          (currentFee) => currentFee.multiply(INPUT_FRACTION_AFTER_FEE),\r\n          ONE_HUNDRED_PERCENT\r\n        )\r\n      );\r\n\r\n  // remove lp fees from price impact\r\n  const priceImpactWithoutFeeFraction =\r\n    trade && realizedLPFee\r\n      ? trade.priceImpact.subtract(realizedLPFee)\r\n      : undefined;\r\n\r\n  // the x*y=k impact\r\n  const priceImpactWithoutFeePercent = priceImpactWithoutFeeFraction\r\n    ? new Percent(\r\n        priceImpactWithoutFeeFraction?.numerator,\r\n        priceImpactWithoutFeeFraction?.denominator\r\n      )\r\n    : undefined;\r\n\r\n  // the amount of the input that accrues to LPs\r\n  const realizedLPFeeAmount =\r\n    realizedLPFee &&\r\n    trade &&\r\n    (trade.inputAmount instanceof TokenAmount\r\n      ? new TokenAmount(\r\n          trade.inputAmount.token,\r\n          realizedLPFee.multiply(trade.inputAmount.raw).quotient\r\n        )\r\n      : CurrencyAmount.ether(\r\n          realizedLPFee.multiply(trade.inputAmount.raw).quotient\r\n        ));\r\n\r\n  return {\r\n    priceImpactWithoutFee: priceImpactWithoutFeePercent,\r\n    realizedLPFee: realizedLPFeeAmount,\r\n  };\r\n}\r\n\r\n// get user token balance in BigNumber\r\nexport async function getUserTokenBalanceRaw(token, account, library) {\r\n  if (token === ETHER) {\r\n    return await library.getBalance(account);\r\n  } else {\r\n    let contractToCheckForBalance = getContract(\r\n      token.address,\r\n      ERC20ABI,\r\n      library,\r\n      account\r\n    );\r\n    return await contractToCheckForBalance.balanceOf(account);\r\n  }\r\n}\r\n\r\n// get user token balance in readable string foramt\r\nexport async function getUserTokenBalance(token, chainId, account, library) {\r\n  let { address, symbol, decimal } = token;\r\n\r\n  if (!token) return;\r\n  let tokenIsETH = symbol === \"ETH\";\r\n\r\n  return formatUnits(\r\n    await getUserTokenBalanceRaw(\r\n      tokenIsETH ? ETHER : new Token(chainId, address, decimal, symbol),\r\n      account,\r\n      library\r\n    ),\r\n    decimal\r\n  );\r\n}\r\n\r\n// return slippage adjusted amount for arguments when adding liquidity. Returns JSBI\r\nexport function calculateSlippageAmount(value, slippage) {\r\n  if (slippage < 0 || slippage > 10000) {\r\n    throw Error(`Unexpected slippage value: ${slippage}`);\r\n  }\r\n  return [\r\n    JSBI.divide(\r\n      JSBI.multiply(value.raw, JSBI.BigInt(10000 - slippage)),\r\n      JSBI.BigInt(10000)\r\n    ),\r\n    JSBI.divide(\r\n      JSBI.multiply(value.raw, JSBI.BigInt(10000 + slippage)),\r\n      JSBI.BigInt(10000)\r\n    ),\r\n  ];\r\n}\r\n\r\n// approve an ERC-20 token\r\nexport async function approve(tokenAddress, requiredAmount, library, account) {\r\n  if (requiredAmount === \"0\") {\r\n    console.log(\"Unncessary call to approve\");\r\n    return true;\r\n  }\r\n\r\n  let allowance = await getAllowance(\r\n    tokenAddress,\r\n    account, // owner\r\n    ROUTER_ADDRESS, //spender\r\n    library, // provider\r\n    account // active account\r\n  );\r\n\r\n  console.log(`ALLOWANCE FOR TOKEN ${tokenAddress}`);\r\n  console.log(allowance);\r\n\r\n  console.log(\"REquired amount\");\r\n  console.log(requiredAmount);\r\n  if (allowance.lt(BigNumber.from(requiredAmount))) {\r\n    let tokenContract = getContract(tokenAddress, ERC20ABI, library, account);\r\n    let useExact = false;\r\n    console.log(\"NOT ENOUGH ALLOWANCE\");\r\n    // try to get max allowance\r\n    let estimatedGas = await tokenContract.estimateGas[\"approve\"](\r\n      ROUTER_ADDRESS,\r\n      MaxUint256\r\n    ).catch(async () => {\r\n      // general fallback for tokens who restrict approval amounts\r\n      useExact = true;\r\n      let result = await tokenContract.estimateGas.approve(\r\n        ROUTER_ADDRESS,\r\n        requiredAmount.raw.toString()\r\n      );\r\n      return result;\r\n    });\r\n\r\n    console.log(`Exact? ${useExact}`);\r\n    let res = await tokenContract\r\n      .approve(\r\n        ROUTER_ADDRESS,\r\n        useExact ? requiredAmount.raw.toString() : MaxUint256,\r\n        {\r\n          gasLimit: calculateGasMargin(estimatedGas),\r\n        }\r\n      )\r\n      .catch(() => {\r\n        console.log(\"not approve success\");\r\n        return false;\r\n      });\r\n    console.log(res);\r\n\r\n    if (res == false) {\r\n      return false;\r\n    }\r\n\r\n    let flag = false;\r\n\r\n    while (1) {\r\n      let newAllowance = await getAllowance(\r\n        tokenAddress,\r\n        account, // owner\r\n        ROUTER_ADDRESS, //spender\r\n        library, // provider\r\n        account // active account\r\n      );\r\n\r\n      if (newAllowance.gte(BigNumber.from(requiredAmount))) {\r\n        flag = true;\r\n        break;\r\n      }\r\n    }\r\n    if (flag) return true;\r\n  } else {\r\n    console.log(\"Allowance sufficient\");\r\n    return true;\r\n  }\r\n}\r\n\r\n// should be used in polling to check status of token approval every n seconds\r\nexport async function checkTokenIsApproved(\r\n  tokenAddress,\r\n  requiredAmount,\r\n  library,\r\n  account\r\n) {\r\n  let allowance = await getAllowance(\r\n    tokenAddress,\r\n    account, // owner\r\n    ROUTER_ADDRESS, //spender\r\n    library, // provider\r\n    account // active account\r\n  );\r\n\r\n  console.log(\"REQUIRED AMOUNT:\");\r\n  console.log(requiredAmount);\r\n  console.log(`ALLOWANCE FOR TOKEN ${tokenAddress}:`);\r\n  console.log(allowance);\r\n  return allowance.gte(BigNumber.from(requiredAmount));\r\n}\r\n\r\n// get total supply of a ERC-20 token, can be liquidity token\r\nexport async function getTokenTotalSupply(token, library, account) {\r\n  let tokenContract = getContract(token.address, ERC20ABI, library, account);\r\n  let totalSupply = await tokenContract.totalSupply();\r\n  let parsedResult = new TokenAmount(token, totalSupply.toString());\r\n\r\n  return parsedResult;\r\n}\r\n","D:\\GitHub\\acy-dex-swap\\src\\components\\Navbar.jsx",[],"D:\\GitHub\\acy-dex-swap\\src\\components\\NotFound.jsx",[],"D:\\GitHub\\acy-dex-swap\\src\\components\\Home.jsx",[],"D:\\GitHub\\acy-dex-swap\\src\\components\\Transaction.jsx",[],"D:\\GitHub\\acy-dex-swap\\src\\components\\Liquidity.jsx",[],{"ruleId":"130","replacedBy":"131"},{"ruleId":"132","replacedBy":"133"},{"ruleId":"134","severity":1,"message":"135","line":5,"column":8,"nodeType":"136","messageId":"137","endLine":5,"endColumn":19},{"ruleId":"134","severity":1,"message":"138","line":31,"column":5,"nodeType":"136","messageId":"137","endLine":31,"endColumn":9},{"ruleId":"134","severity":1,"message":"139","line":84,"column":13,"nodeType":"136","messageId":"137","endLine":84,"endColumn":21},{"ruleId":"140","severity":1,"message":"141","line":100,"column":39,"nodeType":"142","messageId":"143","endLine":100,"endColumn":41},{"ruleId":"140","severity":1,"message":"141","line":102,"column":40,"nodeType":"142","messageId":"143","endLine":102,"endColumn":42},{"ruleId":"140","severity":1,"message":"141","line":104,"column":38,"nodeType":"142","messageId":"143","endLine":104,"endColumn":40},{"ruleId":"140","severity":1,"message":"141","line":106,"column":38,"nodeType":"142","messageId":"143","endLine":106,"endColumn":40},{"ruleId":"144","severity":1,"message":"145","line":709,"column":28,"nodeType":"146","endLine":709,"endColumn":60},{"ruleId":"147","severity":1,"message":"148","line":842,"column":8,"nodeType":"149","endLine":842,"endColumn":107,"suggestions":"150"},{"ruleId":"147","severity":1,"message":"151","line":845,"column":8,"nodeType":"149","endLine":845,"endColumn":107,"suggestions":"152"},{"ruleId":"140","severity":1,"message":"141","line":848,"column":21,"nodeType":"142","messageId":"143","endLine":848,"endColumn":23},{"ruleId":"140","severity":1,"message":"141","line":874,"column":53,"nodeType":"142","messageId":"143","endLine":874,"endColumn":55},{"ruleId":"140","severity":1,"message":"141","line":921,"column":53,"nodeType":"142","messageId":"143","endLine":921,"endColumn":55},{"ruleId":"140","severity":1,"message":"141","line":981,"column":33,"nodeType":"142","messageId":"143","endLine":981,"endColumn":35},{"ruleId":"140","severity":1,"message":"141","line":986,"column":43,"nodeType":"142","messageId":"143","endLine":986,"endColumn":45},{"ruleId":"140","severity":1,"message":"141","line":1007,"column":37,"nodeType":"142","messageId":"143","endLine":1007,"endColumn":39},{"ruleId":"140","severity":1,"message":"141","line":93,"column":39,"nodeType":"142","messageId":"143","endLine":93,"endColumn":41},{"ruleId":"140","severity":1,"message":"141","line":95,"column":40,"nodeType":"142","messageId":"143","endLine":95,"endColumn":42},{"ruleId":"140","severity":1,"message":"141","line":97,"column":39,"nodeType":"142","messageId":"143","endLine":97,"endColumn":41},{"ruleId":"140","severity":1,"message":"141","line":99,"column":40,"nodeType":"142","messageId":"143","endLine":99,"endColumn":42},{"ruleId":"153","severity":1,"message":"154","line":396,"column":25,"nodeType":"155","messageId":"156","endLine":396,"endColumn":62},{"ruleId":"153","severity":1,"message":"154","line":401,"column":25,"nodeType":"155","messageId":"156","endLine":402,"endColumn":40},{"ruleId":"134","severity":1,"message":"157","line":591,"column":21,"nodeType":"136","messageId":"137","endLine":591,"endColumn":35},{"ruleId":"134","severity":1,"message":"158","line":597,"column":21,"nodeType":"136","messageId":"137","endLine":597,"endColumn":35},{"ruleId":"144","severity":1,"message":"145","line":694,"column":28,"nodeType":"146","endLine":694,"endColumn":60},{"ruleId":"147","severity":1,"message":"148","line":943,"column":8,"nodeType":"149","endLine":943,"endColumn":106,"suggestions":"159"},{"ruleId":"147","severity":1,"message":"151","line":946,"column":8,"nodeType":"149","endLine":946,"endColumn":106,"suggestions":"160"},{"ruleId":"140","severity":1,"message":"141","line":950,"column":21,"nodeType":"142","messageId":"143","endLine":950,"endColumn":23},{"ruleId":"140","severity":1,"message":"161","line":961,"column":25,"nodeType":"142","messageId":"143","endLine":961,"endColumn":27},{"ruleId":"140","severity":1,"message":"141","line":992,"column":53,"nodeType":"142","messageId":"143","endLine":992,"endColumn":55},{"ruleId":"140","severity":1,"message":"141","line":1039,"column":53,"nodeType":"142","messageId":"143","endLine":1039,"endColumn":55},{"ruleId":"140","severity":1,"message":"141","line":1101,"column":45,"nodeType":"142","messageId":"143","endLine":1101,"endColumn":47},{"ruleId":"140","severity":1,"message":"141","line":1109,"column":43,"nodeType":"142","messageId":"143","endLine":1109,"endColumn":45},{"ruleId":"140","severity":1,"message":"141","line":1148,"column":59,"nodeType":"142","messageId":"143","endLine":1148,"endColumn":61},{"ruleId":"140","severity":1,"message":"141","line":1164,"column":45,"nodeType":"142","messageId":"143","endLine":1164,"endColumn":47},{"ruleId":"140","severity":1,"message":"141","line":1170,"column":43,"nodeType":"142","messageId":"143","endLine":1170,"endColumn":45},{"ruleId":"140","severity":1,"message":"141","line":1207,"column":59,"nodeType":"142","messageId":"143","endLine":1207,"endColumn":61},{"ruleId":"140","severity":1,"message":"141","line":1225,"column":37,"nodeType":"142","messageId":"143","endLine":1225,"endColumn":39},{"ruleId":"134","severity":1,"message":"162","line":12,"column":5,"nodeType":"136","messageId":"137","endLine":12,"endColumn":17},{"ruleId":"140","severity":1,"message":"141","line":305,"column":27,"nodeType":"142","messageId":"143","endLine":305,"endColumn":29},{"ruleId":"153","severity":1,"message":"154","line":463,"column":5,"nodeType":"163","messageId":"156","endLine":463,"endColumn":12},{"ruleId":"134","severity":1,"message":"164","line":566,"column":17,"nodeType":"136","messageId":"137","endLine":566,"endColumn":32},{"ruleId":"140","severity":1,"message":"161","line":700,"column":36,"nodeType":"142","messageId":"143","endLine":700,"endColumn":38},{"ruleId":"140","severity":1,"message":"141","line":710,"column":35,"nodeType":"142","messageId":"143","endLine":710,"endColumn":37},{"ruleId":"140","severity":1,"message":"141","line":809,"column":22,"nodeType":"142","messageId":"143","endLine":809,"endColumn":24},{"ruleId":"140","severity":1,"message":"141","line":809,"column":37,"nodeType":"142","messageId":"143","endLine":809,"endColumn":39},{"ruleId":"140","severity":1,"message":"141","line":811,"column":18,"nodeType":"142","messageId":"143","endLine":811,"endColumn":20},{"ruleId":"140","severity":1,"message":"141","line":811,"column":32,"nodeType":"142","messageId":"143","endLine":811,"endColumn":34},{"ruleId":"140","severity":1,"message":"141","line":813,"column":17,"nodeType":"142","messageId":"143","endLine":813,"endColumn":19},{"ruleId":"140","severity":1,"message":"141","line":813,"column":32,"nodeType":"142","messageId":"143","endLine":813,"endColumn":34},{"ruleId":"140","severity":1,"message":"141","line":815,"column":17,"nodeType":"142","messageId":"143","endLine":815,"endColumn":19},{"ruleId":"140","severity":1,"message":"141","line":815,"column":30,"nodeType":"142","messageId":"143","endLine":815,"endColumn":32},{"ruleId":"140","severity":1,"message":"141","line":817,"column":18,"nodeType":"142","messageId":"143","endLine":817,"endColumn":20},{"ruleId":"140","severity":1,"message":"141","line":819,"column":18,"nodeType":"142","messageId":"143","endLine":819,"endColumn":20},{"ruleId":"134","severity":1,"message":"165","line":972,"column":17,"nodeType":"136","messageId":"137","endLine":972,"endColumn":25},{"ruleId":"134","severity":1,"message":"166","line":975,"column":17,"nodeType":"136","messageId":"137","endLine":975,"endColumn":22},{"ruleId":"167","severity":1,"message":"168","line":982,"column":17,"nodeType":"169","messageId":"170","endLine":982,"endColumn":107,"fix":"171"},{"ruleId":"167","severity":1,"message":"172","line":983,"column":17,"nodeType":"169","messageId":"170","endLine":983,"endColumn":107,"fix":"173"},{"ruleId":"144","severity":1,"message":"145","line":1119,"column":25,"nodeType":"146","endLine":1119,"endColumn":57},{"ruleId":"134","severity":1,"message":"174","line":1129,"column":10,"nodeType":"136","messageId":"137","endLine":1129,"endColumn":18},{"ruleId":"134","severity":1,"message":"175","line":1129,"column":20,"nodeType":"136","messageId":"137","endLine":1129,"endColumn":31},{"ruleId":"147","severity":1,"message":"176","line":1216,"column":8,"nodeType":"149","endLine":1216,"endColumn":92,"suggestions":"177"},{"ruleId":"147","severity":1,"message":"178","line":1221,"column":8,"nodeType":"149","endLine":1221,"endColumn":92,"suggestions":"179"},{"ruleId":"140","severity":1,"message":"141","line":1224,"column":21,"nodeType":"142","messageId":"143","endLine":1224,"endColumn":23},{"ruleId":"140","severity":1,"message":"141","line":1372,"column":35,"nodeType":"142","messageId":"143","endLine":1372,"endColumn":37},{"ruleId":"134","severity":1,"message":"180","line":8,"column":10,"nodeType":"136","messageId":"137","endLine":8,"endColumn":20},{"ruleId":"134","severity":1,"message":"181","line":13,"column":3,"nodeType":"136","messageId":"137","endLine":13,"endColumn":12},{"ruleId":"134","severity":1,"message":"182","line":14,"column":3,"nodeType":"136","messageId":"137","endLine":14,"endColumn":8},{"ruleId":"134","severity":1,"message":"183","line":15,"column":3,"nodeType":"136","messageId":"137","endLine":15,"endColumn":8},{"ruleId":"134","severity":1,"message":"184","line":16,"column":3,"nodeType":"136","messageId":"137","endLine":16,"endColumn":10},{"ruleId":"134","severity":1,"message":"185","line":18,"column":3,"nodeType":"136","messageId":"137","endLine":18,"endColumn":7},{"ruleId":"134","severity":1,"message":"186","line":21,"column":3,"nodeType":"136","messageId":"137","endLine":21,"endColumn":28},{"ruleId":"140","severity":1,"message":"141","line":275,"column":13,"nodeType":"142","messageId":"143","endLine":275,"endColumn":15},"no-native-reassign",["187"],"no-negated-in-lhs",["188"],"no-unused-vars","'Transaction' is defined but never used.","Identifier","unusedVar","'Pair' is defined but never used.","'contract' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","react/jsx-no-target-blank","Using target=\"_blank\" without rel=\"noreferrer\" is a security risk: see https://html.spec.whatwg.org/multipage/links.html#link-type-noopener","JSXOpeningElement","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 't0Changed'. Either include it or remove the dependency array.","ArrayExpression",["189"],"React Hook useEffect has a missing dependency: 't1Changed'. Either include it or remove the dependency array.",["190"],"no-unreachable","Unreachable code.","ExpressionStatement","unreachableCode","'inToken0Amount' is assigned a value but never used.","'inToken1Amount' is assigned a value but never used.",["191"],["192"],"Expected '!==' and instead saw '!='.","'getAllowance' is defined but never used.","ReturnStatement","'totalPoolTokens' is assigned a value but never used.","'estimate' is defined but never used.","'value' is defined but never used.","no-useless-computed-key","Unnecessarily computed property [\"CURRENCY_A\"] found.","Property","unnecessarilyComputedProperty",{"range":"193","text":"194"},"Unnecessarily computed property [\"CURRENCY_B\"] found.",{"range":"195","text":"196"},"'position' is assigned a value but never used.","'setPosition' is assigned a value but never used.","React Hook useCallback has missing dependencies: 'token0Amount' and 'token1Amount'. Either include them or remove the dependency array.",["197"],"React Hook useEffect has a missing dependency: 'inputChange'. Either include it or remove the dependency array.",["198"],"'parseUnits' is defined but never used.","'TradeType' is defined but never used.","'Route' is defined but never used.","'Trade' is defined but never used.","'Fetcher' is defined but never used.","'WETH' is defined but never used.","'InsufficientReservesError' is defined but never used.","no-global-assign","no-unsafe-negation",{"desc":"199","fix":"200"},{"desc":"201","fix":"202"},{"desc":"199","fix":"203"},{"desc":"201","fix":"204"},[33626,33640],"\"CURRENCY_A\"",[33735,33749],"\"CURRENCY_B\"",{"desc":"205","fix":"206"},{"desc":"207","fix":"208"},"Update the dependencies array to be: [token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account, t0Changed]",{"range":"209","text":"210"},"Update the dependencies array to be: [token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account, t1Changed]",{"range":"211","text":"212"},{"range":"213","text":"210"},{"range":"214","text":"212"},"Update the dependencies array to be: [token0, token1, token0Amount, token1Amount, index, percent, amount, chainId, library, account]",{"range":"215","text":"216"},"Update the dependencies array to be: [token0, token1, index, percent, amount, slippageTolerance, chainId, library, account, inputChange]",{"range":"217","text":"218"},[31761,31860],"[token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account, t0Changed]",[31916,32015],"[token0, token1, token0Amount, token1Amount, slippageTolerance, exactIn, chainId, library, account, t1Changed]",[35655,35753],[35809,35907],[42764,42848],"[token0, token1, token0Amount, token1Amount, index, percent, amount, chainId, library, account]",[42912,42996],"[token0, token1, index, percent, amount, slippageTolerance, chainId, library, account, inputChange]"]